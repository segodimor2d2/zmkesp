=== CONSOLIDAÇÃO DE CÓDIGOS DA PASTA: alesp ===



=== ARQUIVO: alesp/config.py ===

# -----------------------------
# CONFIGURAÇÕES DO SISTEMA
# -----------------------------

# Pinos dos touchpads
THIS_IS = 0 # 0=L, 1=R

# Potenciômetros
## Thresholds individuais
THRESH_POT = [-120] * 5 # -50 (muito sensível) e -200 (pouco sensível)
POT_CALIBRATION_SAMPLES = 40 # 20 (rápido) e 100 (preciso)
POT_CALIBRATION_DELAY_MS = 70 # 0ms e 100ms. 70ms permite leituras estáveis

# Giroscópio
## Limite base para thresholds
PORAGORA = 14000        # 8000 (mais sensível) e 20000 (menos sensível)
# Percentual usado para criar thresholds
THRES_PERCENT = 0.1     # 0.05 (5%) e 0.2 (20%). 0.1 (10%)

# Controle de passos automáticos
STEP_WAIT_LIMIT = 5     # Quantos ciclos esperar antes de repetir passo

# Reset
CYCLE_RESET_LIMIT = 20  # Quantos ciclos parado até resetar stepX/stepY

# Loop principal
TSLEEP = 50             # Delay entre loops (ms)
TCLEAR = 10000          # Intervalo para reset de contador
SAMPLES = 5             # Amostras iniciais do giroscópio

# Ordem dos eixos do giroscópio
GY1, GY2 = 1, 0         # Eixo X primeiro, depois Y

# Inverter sentido do eixo X e/ou Y
INVERT_X = False         # True re(+) ar(-) False o contrario
INVERT_Y = True         # True re(+) ar(-) False o contrario

PINOS_R = 13,12,14,27,4
INDEX_MAP_R = 0,1,2,3,4
PINOS_VIB_R = 26

PINOS_L = 12,13,14,27,4
INDEX_MAP_L = 0,1,2,4,3
PINOS_VIB_L = 26


# -----------------------------
# DEBUG
# -----------------------------
DEBUG = 0
"""
| Você Quer...                  | Configuração        | Comportamento          |
|-------------------------------|---------------------|------------------------|
| Só logs de nível X            | `DEBUG = X`         | Ignora tudo ≠ X        |
| Todos os logs                 | `DEBUG = None`      | Mostra tudo            |
| Logs sem nível                | `DEBUG = -1`        | Mostra só os sem nível |
| Múltiplos níveis (ex: 0,1,2)  | `DEBUG = [0, 1, 2]` | Mostra só esses níveis |
"""




=== ARQUIVO: alesp/actions.py ===

from machine import Pin, UART
import time

# UART - ajuste TX e RX conforme o seu hardware
uart = UART(1, baudrate=115200, tx=17, rx=16)

def send_charPs(zmkcodes):
    if zmkcodes is not None:
        print(zmkcodes)
        row = zmkcodes[0]
        col = zmkcodes[1]

        # Proteção: valores devem estar entre 0 e 255
        if not (0 <= row <= 255 and 0 <= col <= 255):
            print(f"[WARNING] row/col fora do range: row={row}, col={col}")
            return

        if zmkcodes[2] == 0:
            event_type = 0x00
        else:
            event_type = 0x01

        checksum = event_type ^ row ^ col
        packet = bytes([0xAA, event_type, row, col, checksum])
        # print(packet)
        uart.write(packet)

def tstpot(row, col, delay=0.1):
    send_charPs([row, col, True])
    time.sleep(delay)
    send_charPs([row, col, False])

def vibrar(pino_vibracao, n_pulsos, step=None):
    if pino_vibracao is None:
        print("vibrador não inicializado")
        return
    for _ in range(n_pulsos):
        try:
            pino_vibracao.on()
        except Exception:
            # alguns firmwares usam value(1)/value(0)
            try: pino_vibracao.value(1)
            except: pass
        if step == 0:
            time.sleep_ms(200)
        else:
            time.sleep_ms(101)
        try:
            pino_vibracao.off()
        except Exception:
            try: pino_vibracao.value(0)
            except: pass
        time.sleep_ms(70)



=== ARQUIVO: alesp/hw.py ===

from machine import Pin, SoftI2C, TouchPad
import time
import config

if config.THIS_IS == 1:
    pinos = config.PINOS_R
    pinos_vib = config.PINOS_VIB_R

if config.THIS_IS == 0:
    pinos = config.PINOS_L
    pinos_vib = config.PINOS_VIB_L

def init_i2c(scl_pin=22, sda_pin=21):
    return SoftI2C(scl=Pin(scl_pin), sda=Pin(sda_pin))

def init_mpu(i2c):
    # importa aqui para evitar erro se rodar testes sem MPU
    try:
        import mpu6050
        mpu = mpu6050.MPU6050(i2c)
        return mpu
    except Exception as e:
        print("init_mpu erro:", e)
        return None

def init_vibrator(pin_no=(pinos_vib)):
    p = Pin(pin_no, Pin.OUT)
    try:
        p.off()
    except Exception:
        pass
    return p

def init_pots(pins=(pinos)):
    return [TouchPad(Pin(p)) for p in pins]

# teste rápido:
if __name__ == "__main__":
    i2c = init_i2c()
    mpu = init_mpu(i2c)
    vib = init_vibrator()
    pots = init_pots()
    print("hw init done, mpu:", bool(mpu), "pots:", [type(p) for p in pots])


=== ARQUIVO: alesp/dicctozmk.py ===



# --- Mapas de tradução (lado esquerdo e lado direito) ---

## M=Moto, Y=Yave [M,Y]
## pot [gx, gy] status [M,Y]

MAPL = {
    # abclevel, gx, gy: (row, col)

    # --- Gyro (1,0) [P,M,T] ---
    (0,  1,  0): (3, 2),  # space
    (1,  1,  0): (0, 4),  # r
    (2,  1,  0): (0, 3),  # e
    (3,  1,  0): (0, 2),  # w
    (4,  1,  0): (0, 1),  # q

    # --- Gyro (0,0) [P,M,T] ---
    (0,  0,  0): (3, 2),  # space
    (1,  0,  0): (1, 4),  # f
    (2,  0,  0): (1, 3),  # d
    (3,  0,  0): (1, 2),  # s
    (4,  0,  0): (1, 1),  # a

    # --- Gyro (-1,0) [P,M,T] ---
    (0, -1,  0): (3, 2),  # space
    (1, -1,  0): (2, 4),  # v
    (2, -1,  0): (2, 3),  # c
    (3, -1,  0): (2, 2),  # x
    (4, -1,  0): (2, 1),  # z

    # --- Gyro (1,1) [P,M,T] ---
    (0,  1,  1): (3, 2),  # space
    (1,  1,  1): (0, 5),  # t
    (4,  1,  1): (0, 0),  # esc

    # --- Gyro (0,1) [P,M,T] ---
    (0,  0,  1): (3, 2),  # space
    (1,  0,  1): (1, 5),  # g
    (4,  0,  1): (0, 0),  # esc

    # --- Gyro (-1,1) [P,M,T] ---
    (0, -1,  1): (3, 2),  # space
    (1, -1,  1): (2, 5),  # b
    (4, -1,  1): (0, 0),  # esc

}

MAPR = {
    # --- Gyro (1,0) [P,M,T] ---
    (0,  1,  0): (3, 3),   # enter
    (1,  1,  0): (0, 7),   # u
    (2,  1,  0): (0, 8),   # i
    (3,  1,  0): (0, 9),   # o
    (4,  1,  0): (0, 10),  # p
    # --- Gyro (1,1) [P,M,T] ---
    (0,  1,  1): (3, 3),   # enter
    (1,  1,  1): (0, 6),   # y
    (4,  1,  1): (0, 11),  # backspace

    # --- Gyro (0,0) [P,M,T] ---
    (0,  0,  0): (3, 3),   # enter
    (1,  0,  0): (1, 7),   # j
    (2,  0,  0): (1, 8),   # k
    (3,  0,  0): (1, 9),   # l
    (4,  0,  0): (1, 10),  # c
    # --- Gyro (0,1) [P,M,T] ---
    (0,  0,  1): (3, 3),   # enter
    (1,  0,  1): (1, 6),   # h
    (4,  0,  1): (0, 11),  # backspace

    # --- Gyro (-1,0) [P,M,T] ---
    (0, -1,  0): (3, 3),   # enter
    (1, -1,  0): (2, 7),  # m
    (2, -1,  0): (2, 8),  # ,
    (3, -1,  0): (2, 9),  # .
    (4, -1,  0): (2, 10), # ;
    # --- Gyro (-1,1) [P,M,T] ---
    (0,  -1, 1): (3, 3),   # enter
    (1,  -1, 1): (2, 6),   # n
    (4,  -1, 1): (0, 11),  # backspace

}

def potsgyrotozmk(abclevel, mapped_i, status, side):
    print(abclevel, mapped_i, status, side)
    """
    Traduz (abclevel, gx, gy, status) -> (row, col, status)
    side: 0 = left, 1 = right
    """
    mapping = MAPL if side == 0 else MAPR
    key = (mapped_i, abclevel[0], abclevel[1])
    if key not in mapping:
        return None  # tecla não mapeada
    row, col = mapping[key]
    return row, col, status



=== ARQUIVO: alesp/pots.py ===

def add_pot_samples(bufferPot, pval):
    """bufferPot: list de listas; pval: lista com leituras atuais"""
    for i, v in enumerate(pval):
        bufferPot[i].append(v)
    return bufferPot

def calc_calibrate(bufferPot):
    """Retorna lista com max por pot (ou 0 se vazio)"""
    maxCalc = []
    for potList in bufferPot:
        maxCalc.append(max(potList) if potList else 0)
    return maxCalc


=== ARQUIVO: alesp/gyro.py ===

def append_gyro(buffer, mpuSensor):
    """Adiciona uma leitura ao buffer (6 listas)"""
    if mpuSensor is None:
        # evita crash se MPU não inicializou
        return buffer
    try:
        mpuData = mpuSensor.get_values()
    except Exception as e:
        print("MPU read error:", e)
        return buffer

    keys = ['GyX','GyY','GyZ','AcX','AcY','AcZ']
    for i, k in enumerate(keys):
        buffer[i].append(mpuData.get(k, 0))
    return buffer

def average_and_slide(buffer, mpuSensor):
    """Lê mais um valor, calcula média e remove o mais antigo (sliding window)"""
    append_gyro(buffer, mpuSensor)
    averages = []
    for lst in buffer:
        averages.append(sum(lst)/len(lst) if lst else 0)
    gyro = averages[:3]
    accl = averages[3:6]
    # remove o mais antigo para manter a janela
    for lst in buffer:
        if lst:
            lst.pop(0)
    return gyro, accl


=== ARQUIVO: alesp/mpu6050.py ===

import machine

class MPU6050():
    def __init__(self, i2c, addr=0x68):
        self.iic = i2c
        self.addr = addr
        self.iic.start()
        self.iic.writeto(self.addr, bytearray([107, 0]))
        self.iic.stop()

    def get_raw_values(self):
        self.iic.start()
        a = self.iic.readfrom_mem(self.addr, 0x3B, 14)
        self.iic.stop()
        return a

    def get_ints(self):
        b = self.get_raw_values()
        c = []
        for i in b:
            c.append(i)
        return c

    def bytes_toint(self, firstbyte, secondbyte):
        if not firstbyte & 0x80:
            return firstbyte << 8 | secondbyte
        return - (((firstbyte ^ 255) << 8) | (secondbyte ^ 255) + 1)

    def get_values(self):
        raw_ints = self.get_raw_values()
        vals = {}
        vals["AcX"] = self.bytes_toint(raw_ints[0], raw_ints[1])
        vals["AcY"] = self.bytes_toint(raw_ints[2], raw_ints[3])
        vals["AcZ"] = self.bytes_toint(raw_ints[4], raw_ints[5])
        vals["Tmp"] = self.bytes_toint(raw_ints[6], raw_ints[7]) / 340.00 + 36.53
        vals["GyX"] = self.bytes_toint(raw_ints[8], raw_ints[9])
        vals["GyY"] = self.bytes_toint(raw_ints[10], raw_ints[11])
        vals["GyZ"] = self.bytes_toint(raw_ints[12], raw_ints[13])
        return vals  # returned in range of Int16
        # -32768 to 32767

    def val_test(self):  # ONLY FOR TESTING! Also, fast reading sometimes crashes IIC
        from time import sleep
        while 1:
            print(self.get_values())
            sleep(0.05)



=== ARQUIVO: alesp/main.py ===

import time
import math
import config
from hw import init_i2c, init_mpu, init_vibrator, init_pots
from actions import vibrar, send_charPs
from pots import add_pot_samples, calc_calibrate
from gyro import append_gyro, average_and_slide
from dicctozmk import potsgyrotozmk

if config.THIS_IS == 1:
    INDEX_MAP_POTS = list(config.INDEX_MAP_R)

if config.THIS_IS == 0:
    INDEX_MAP_POTS = list(config.INDEX_MAP_L)

# ===== CONFIGS TOUCH =====
CALIB_SAMPLES   = 100   # Amostras por canal
PRESS_OFFSET    = 50    # Quanto abaixo do baseline aciona
RELEASE_OFFSET  = 30    # Quanto abaixo do baseline libera
DEBOUNCE_COUNT  = 3     # Leituras consecutivas para confirmar toque

# ===== VARIÁVEIS GLOBAIS =====
baseline        = []
press_thresh    = []
release_thresh  = []
pot_counter     = []
triggerPot      = []
pval            = []



# -----------------------------
# Função de log centralizada
# -----------------------------
def log(*args, **kwargs):
    level = None  # Sem nível por padrão
    if len(args) > 1 and isinstance(args[1], int) and args[1] >= 0:
        level = args[1]
        args = (args[0],) + args[2:]  # Remove o level dos args
    
    debug_level = getattr(config, 'DEBUG', None)
    
    if debug_level is not None and level is not None and level != debug_level:
        return
    
    if debug_level is not None and level is None:
        return
    
    print(*args, **kwargs)

# -----------------------------
# Funções auxiliares
# -----------------------------
def calibrate_pots(pots):
    global baseline, press_thresh, release_thresh, pot_counter, triggerPot, pval

    num_pots = len(pots)
    baseline        = [0] * num_pots
    press_thresh    = [0] * num_pots
    release_thresh  = [0] * num_pots
    pot_counter     = [0] * num_pots
    triggerPot      = [False] * num_pots
    pval            = [0] * num_pots

    print("Calibrando... não toque nos sensores.")
    for i in range(num_pots):
        soma = 0
        for _ in range(CALIB_SAMPLES):
            soma += pots[i].read()
            time.sleep_ms(5)
        baseline[i]       = soma / CALIB_SAMPLES
        press_thresh[i]   = baseline[i] - PRESS_OFFSET
        release_thresh[i] = baseline[i] - RELEASE_OFFSET

    print("Baseline:       ", baseline)
    print("Press thresh:   ", press_thresh)
    print("Release thresh: ", release_thresh)

def check_gyro_axis(axis_index, pos_thresh, neg_thresh, step, event_pos, event_neg, vib, wait2Zero, cycle, invert=False):
    """Verifica giroscópio em um eixo e atualiza estado."""
    if not event_pos and gyro[axis_index] > pos_thresh:
        step += -1 if invert else 1
        vibrar(vib, 1, step)
        log(f"[GYRO] Eixo {axis_index} POS -> step={step}")
        event_pos = True
        wait2Zero = True
        cycle = 0
    elif event_pos and gyro[axis_index] <= pos_thresh:
        event_pos = False

    if not event_neg and gyro[axis_index] < neg_thresh:
        step += 1 if invert else -1
        vibrar(vib, 1, step)
        log(f"[GYRO] Eixo {axis_index} NEG -> step={step}")
        event_neg = True
        wait2Zero = True
        cycle = 0
    elif event_neg and gyro[axis_index] >= neg_thresh:
        event_neg = False

    return step, event_pos, event_neg, wait2Zero, cycle

def check_step_wait(event_triggered, step_wait, step, delta, vib):
    """Controle de espera para repetição automática."""
    step_wait = step_wait + 1 if event_triggered else 0
    if step_wait >= config.STEP_WAIT_LIMIT:
        step += delta
        vibrar(vib, 1, step)
        log(f"[STEP_WAIT] step={step} delta={delta}")
        step_wait = 0
    return step_wait, step

def check_pots(pots, abclevel, wait2Zero, cycle):
    global pval, triggerPot, pot_counter

    for i, pot in enumerate(pots):
        val = pot.read()
        pval[i] = val
        mapped_i = INDEX_MAP_POTS[i]

        if not triggerPot[i] and val < press_thresh[i]:
            pot_counter[i] += 1
            if pot_counter[i] >= DEBOUNCE_COUNT:
                send_charPs(potsgyrotozmk(abclevel, mapped_i, 1, config.THIS_IS))
                log(f"[POT{mapped_i}] Pressionado | val={val} | abclevel={abclevel}", 2)
                triggerPot[i] = True
                pot_counter[i] = 0
                wait2Zero = False
                cycle = 0

        elif triggerPot[i] and val > release_thresh[i]:
            pot_counter[i] += 1
            if pot_counter[i] >= DEBOUNCE_COUNT:
                send_charPs(potsgyrotozmk(abclevel, mapped_i, 0, config.THIS_IS))
                log(f"[POT{mapped_i}] Liberado | val={val} | abclevel={abclevel}", 2)
                triggerPot[i] = False
                pot_counter[i] = 0
                wait2Zero = True

        else:
            pot_counter[i] = 0

    return wait2Zero, cycle

# -----------------------------
# Função principal
# -----------------------------
def start(i2c=None, mpu=None, pots=None, vib=None):
    # Inicializa hardware se não passado
    if i2c is None: i2c = init_i2c()
    if mpu is None: mpu = init_mpu(i2c)
    if vib is None: vib = init_vibrator()
    if pots is None: pots = init_pots()
    pot1, pot2, pot3, pot4, pot5 = pots

    # Calibração de pots
    calibrate_pots(pots)

    # Prepara buffer do gyro
    buffer = [[] for _ in range(6)]
    for _ in range(config.SAMPLES - 1):
        append_gyro(buffer, mpu)
        time.sleep_ms(70)
    global gyro
    gyro, accl = average_and_slide(buffer, mpu)

    # Variáveis de estado
    num = 0
    holdclick = False
    triggerPot = [False] * 5
    threshPot = config.THRESH_POT

    # Thresholds giroscópio
    threshP  = config.PORAGORA - (config.PORAGORA * config.THRES_PERCENT)
    threshN  = -config.PORAGORA + (config.PORAGORA * config.THRES_PERCENT)
    threshXP = config.PORAGORA - (config.PORAGORA * config.THRES_PERCENT)
    threshXN = -config.PORAGORA + (config.PORAGORA * config.THRES_PERCENT)

    stepX = stepY = 0
    evntTriggeredXP = evntTriggeredXN = False
    evntTriggeredYP = evntTriggeredYN = False

    wait2Zero = False
    cycle = 0
    stepWaitXP = stepWaitXN = stepWaitYP = stepWaitYN = 0

    gy1, gy2 = config.GY1, config.GY2

    vibrar(vib, 2)

    # Loop principal
    while True:
        gyro, accl = average_and_slide(buffer, mpu)

        # Movimento no eixo X
        stepX, evntTriggeredXP, evntTriggeredXN, wait2Zero, cycle = check_gyro_axis(
            gy1, threshXP, threshXN, stepX, evntTriggeredXP, evntTriggeredXN, vib, wait2Zero, cycle, invert=config.INVERT_X
        )

        # Movimento no eixo Y
        stepY, evntTriggeredYP, evntTriggeredYN, wait2Zero, cycle = check_gyro_axis(
            gy2, threshP, threshN, stepY, evntTriggeredYP, evntTriggeredYN, vib, wait2Zero, cycle, invert=config.INVERT_Y
        )

        # Controle de repetição automática
        invX = -1 if config.INVERT_X else 1
        invY = -1 if config.INVERT_Y else 1

        stepWaitXP, stepX = check_step_wait(evntTriggeredXP, stepWaitXP, stepX, invX * (1 if gy1 == 0 else -1), vib)
        stepWaitXN, stepX = check_step_wait(evntTriggeredXN, stepWaitXN, stepX, invX * (-1 if gy1 == 0 else 1), vib)
        stepWaitYP, stepY = check_step_wait(evntTriggeredYP, stepWaitYP, stepY, invY * (-1 if gy1 == 0 else 1), vib)
        stepWaitYN, stepY = check_step_wait(evntTriggeredYN, stepWaitYN, stepY, invY * (1 if gy1 == 0 else -1), vib)

        # Leitura dos potenciômetros
        abclevel = [stepX, stepY]
        wait2Zero, cycle = check_pots(pots, abclevel, wait2Zero, cycle)

        # Reset se parado
        if wait2Zero and cycle < config.CYCLE_RESET_LIMIT:
            cycle += 1
            if cycle == config.CYCLE_RESET_LIMIT:
                stepY = stepX = 0
                vibrar(vib, 2)
                log("[RESET] StepX e StepY resetados")
                wait2Zero = False
                cycle = 0

        if num % config.TCLEAR == 0:
            num = 0
        num += 1
        time.sleep_ms(config.TSLEEP)

# -----------------------------
# def run():
#     vibrar(init_vibrator(), 4)
#     start()

start()
vibrar(init_vibrator(), 4)


=== ARQUIVO: alesp/no_sue_l/hidcodes.py ===

abc=[
        [
            [
                ['','','','KEY_5','KEY_SPACE'],
                ['','','','KEY_T','KEY_SPACE'],
                ['KEY_ESC','KEY_RSHIFT','','KEY_G','KEY_SPACE'],
                ['','','','KEY_B','KEY_SPACE'],
                ['','','','','KEY_SPACE'],
            ],
            [
                ['KEY_1','KEY_2','KEY_3','KEY_4','KEY_SPACE'],
                ['KEY_Q','KEY_W','KEY_E','KEY_R','KEY_SPACE'],
                ['KEY_A','KEY_S','KEY_D','KEY_F','KEY_SPACE'],
                ['KEY_Z','KEY_X','KEY_C','KEY_V','KEY_SPACE'],
                ['','','','','KEY_SPACE'],
            ],
            [
                ['KEY_GRAVE','','','','KEY_SPACE'],
                ['KEY_TAB','','','','KEY_SPACE'],
                ['KEY_CAPSLOCK','','','','KEY_SPACE'],
                ['KEY_LSHIFT','','','','KEY_SPACE'],
                ['KEY_LCTRL','','','KEY_LALT','KEY_SPACE'],
            ],
        ],
        [
            [
                ['KEY_SPACE','KEY_6','','',''],
                ['KEY_SPACE','KEY_Y','','','KEY_DELETE'],
                ['KEY_SPACE','KEY_H','KEY_ENTER','KEY_RSHIFT','KEY_BACKSPACE'],
                ['KEY_SPACE','KEY_N','','',''],
                ['KEY_SPACE','','','',''],
            ],
            [
                ['KEY_SPACE','KEY_7','KEY_8','KEY_9','KEY_0'],
                ['KEY_SPACE','KEY_U','KEY_I','KEY_O','KEY_P'],
                ['KEY_SPACE','KEY_J','KEY_K','KEY_L','KEY_SEMICOLON'],
                ['KEY_SPACE','KEY_M','KEY_COMMA','KEY_DOT','KEY_SLASH'],
                ['KEY_SPACE','KEY_RALT','KEY_RCTRL','',''],
            ],
            [
                ['KEY_SPACE','','KEY_KPMINUS','KEY_KPPLUS','KEY_BACKSPACE'],
                ['KEY_SPACE','','KEY_LEFTBRACE','KEY_RIGHTBRACE','KEY_BACKSLASH'],
                ['KEY_SPACE','','KEY_SEMICOLON','KEY_APOSTROPHE','KEY_ENTER'],
                ['KEY_SPACE','KEY_COMMA','KEY_DOT','KEY_SLASH','KEY_RSHIFT'],
                ['KEY_SPACE','','','',''],
            ],
        ],
    ]

hidcodes = {
    "KEY_NONE": 0x00,
    "KEY_ERR_OVF": 0x01,
    "KEY_A": 0x04,
    "KEY_B": 0x05,
    "KEY_C": 0x06,
    "KEY_D": 0x07,
    "KEY_E": 0x08,
    "KEY_F": 0x09,
    "KEY_G": 0x0a,
    "KEY_H": 0x0b,
    "KEY_I": 0x0c,
    "KEY_J": 0x0d,
    "KEY_K": 0x0e,
    "KEY_L": 0x0f,
    "KEY_M": 0x10,
    "KEY_N": 0x11,
    "KEY_O": 0x12,
    "KEY_P": 0x13,
    "KEY_Q": 0x14,
    "KEY_R": 0x15,
    "KEY_S": 0x16,
    "KEY_T": 0x17,
    "KEY_U": 0x18,
    "KEY_V": 0x19,
    "KEY_W": 0x1a,
    "KEY_X": 0x1b,
    "KEY_Y": 0x1c,
    "KEY_Z": 0x1d,
    "KEY_1": 0x1e,
    "KEY_2": 0x1f,
    "KEY_3": 0x20,
    "KEY_4": 0x21,
    "KEY_5": 0x22,
    "KEY_6": 0x23,
    "KEY_7": 0x24,
    "KEY_8": 0x25,
    "KEY_9": 0x26,
    "KEY_0": 0x27,
    "KEY_ENTER": 0x28,
    "KEY_ESC": 0x29,
    "KEY_BACKSPACE": 0x2a,
    "KEY_TAB": 0x2b,
    "KEY_SPACE": 0x2c,
    "KEY_MINUS": 0x2d,
    "KEY_EQUAL": 0x2e,
    "KEY_LEFTBRACE": 0x2f,
    "KEY_RIGHTBRACE": 0x30,
    "KEY_BACKSLASH": 0x31,
    "KEY_HASHTILDE": 0x32,
    "KEY_SEMICOLON": 0x33,
    "KEY_APOSTROPHE": 0x34,
    "KEY_GRAVE": 0x35,
    "KEY_COMMA": 0x36,
    "KEY_DOT": 0x37,
    "KEY_SLASH": 0x38,
    "KEY_CAPSLOCK": 0x39,
    "KEY_F1": 0x3a,
    "KEY_F2": 0x3b,
    "KEY_F3": 0x3c,
    "KEY_F4": 0x3d,
    "KEY_F5": 0x3e,
    "KEY_F6": 0x3f,
    "KEY_F7": 0x40,
    "KEY_F8": 0x41,
    "KEY_F9": 0x42,
    "KEY_F10": 0x43,
    "KEY_F11": 0x44,
    "KEY_F12": 0x45,
    "KEY_SYSRQ": 0x46,
    "KEY_SCROLLLOCK": 0x47,
    "KEY_PAUSE": 0x48,
    "KEY_INSERT": 0x49,
    "KEY_HOME": 0x4a,
    "KEY_PAGEUP": 0x4b,
    "KEY_DELETE": 0x4c,
    "KEY_END": 0x4d,
    "KEY_PAGEDOWN": 0x4e,
    "KEY_RIGHT": 0x4f,
    "KEY_LEFT": 0x50,
    "KEY_DOWN": 0x51,
    "KEY_UP": 0x52,
    "KEY_NUMLOCK": 0x53,
    "KEY_KPSLASH": 0x54,
    "KEY_KPASTERISK": 0x55,
    "KEY_KPMINUS": 0x56,
    "KEY_KPPLUS": 0x57,
    "KEY_KPENTER": 0x58,
    "KEY_KP1": 0x59,
    "KEY_KP2": 0x5a,
    "KEY_KP3": 0x5b,
    "KEY_KP4": 0x5c,
    "KEY_KP5": 0x5d,
    "KEY_KP6": 0x5e,
    "KEY_KP7": 0x5f,
    "KEY_KP8": 0x60,
    "KEY_KP9": 0x61,
    "KEY_KP0": 0x62,
    "KEY_KPDOT": 0x63,
    "KEY_102ND": 0x64,
    "KEY_COMPOSE": 0x65,
    "KEY_POWER": 0x66,
    "KEY_KPEQUAL": 0x67,
    "KEY_F13": 0x68,
    "KEY_F14": 0x69,
    "KEY_F15": 0x6a,
    "KEY_F16": 0x6b,
    "KEY_F17": 0x6c,
    "KEY_F18": 0x6d,
    "KEY_F19": 0x6e,
    "KEY_F20": 0x6f,
    "KEY_F21": 0x70,
    "KEY_F22": 0x71,
    "KEY_F23": 0x72,
    "KEY_F24": 0x73,
    "KEY_OPEN": 0x74,
    "KEY_HELP": 0x75,
    "KEY_PROPS": 0x76,
    "KEY_FRONT": 0x77,
    "KEY_STOP": 0x78,
    "KEY_AGAIN": 0x79,
    "KEY_UNDO": 0x7a,
    "KEY_CUT": 0x7b,
    "KEY_COPY": 0x7c,
    "KEY_PASTE": 0x7d,
    "KEY_FIND": 0x7e,
    "KEY_MUTE": 0x7f,
    "KEY_VOLUMEUP": 0x80,
    "KEY_VOLUMEDOWN": 0x81,
    "KEY_MEDIA_PLAYPAUSE": 0xe8,
    "KEY_MEDIA_STOPCD": 0xe9,
    "KEY_MEDIA_PREVIOUSSONG": 0xea,
    "KEY_MEDIA_NEXTSONG": 0xeb,
    "KEY_MEDIA_EJECTCD": 0xec,
    "KEY_MEDIA_VOLUMEUP": 0xed,
    "KEY_MEDIA_VOLUMEDOWN": 0xee,
    "KEY_MEDIA_MUTE": 0xef,
    "KEY_MEDIA_WWW": 0xf0,
    "KEY_MEDIA_BACK": 0xf1,
    "KEY_MEDIA_FORWARD": 0xf2,
    "KEY_MEDIA_STOP": 0xf3,
    "KEY_MEDIA_FIND": 0xf4,
    "KEY_MEDIA_SCROLLUP": 0xf5,
    "KEY_MEDIA_SCROLLDOWN": 0xf6,
    "KEY_MEDIA_EDIT": 0xf7,
    "KEY_MEDIA_SLEEP": 0xf8,
    "KEY_MEDIA_COFFEE": 0xf9,
    "KEY_MEDIA_REFRESH": 0xfa,
    "KEY_MEDIA_CALC": 0xfb
}


=== ARQUIVO: alesp/no_sue_l/bkpmain.py ===

import time
import math
import mpu6050
from machine import Pin, SoftI2C, ADC, TouchPad
#from hid_services import Keyboard
import network
import espnow

print()
print('*********************************')

def send_charPs(abckey, stt, peer):
    msg = '%s;%s' % (abckey,stt)
    #e.send(peer, msg, True)
    e.send(peer, msg)

def vibrar(n_pulsos, step=None):
    for _ in range(n_pulsos):
        pino_vibracao.on()
        if step == 0:
            time.sleep_ms(200)
        else:
            #time.sleep_ms(70)
            time.sleep_ms(100)        
        #time.sleep_ms(200)
        pino_vibracao.off()
        time.sleep_ms(70)

def calclim(lim,val):
    lst = (lim[0],lim[1],val)
    lim[0] = max(lst)
    lim[1] = min(lst)
    lim[2] = val
    return lim 

def getPots(bufferPot,pval):
    bufferPot[0].append(pval[0])
    bufferPot[1].append(pval[1])
    bufferPot[2].append(pval[2])
    bufferPot[3].append(pval[3])
    bufferPot[4].append(pval[4])
    return bufferPot

def calcCalibrate(bufferPot):
    maxCalc = [] 
    for potList in bufferPot:
        maxCalc.append(max(potList))
    return maxCalc


def getGyro(buffer):
    mpuData = mpuSensor.get_values()
    buffer[0].append(mpuData['GyX'])
    buffer[1].append(mpuData['GyY'])
    buffer[2].append(mpuData['GyZ'])
    buffer[3].append(mpuData['AcX'])
    buffer[4].append(mpuData['AcY'])
    buffer[5].append(mpuData['AcZ'])
    return buffer

def media(buffer):
    getGyro(buffer)
    xgyro = sum(buffer[0])/len(buffer[0])
    ygyro = sum(buffer[1])/len(buffer[1])
    zgyro = sum(buffer[2])/len(buffer[2])
    xaccl = sum(buffer[3])/len(buffer[3])
    yaccl = sum(buffer[4])/len(buffer[4])
    zaccl = sum(buffer[5])/len(buffer[5])
    gyro = [xgyro,ygyro,zgyro]
    accl = [xaccl,yaccl,zaccl]
    buffer[0].pop(0)
    buffer[1].pop(0)
    buffer[2].pop(0)
    buffer[3].pop(0)
    buffer[4].pop(0)
    buffer[5].pop(0)
    return gyro,accl

def startlim(arrlim,vals):
    for i in range(len(arrlim)):
        arrlim[i] = [vals[i]] * 3
    return arrlim

def startlimpot(arrlim,vals):
    for i in range(len(arrlim)):
        arrlim[i] = vals
    return arrlim

def run(tsleep,tclear,samples,e,peer):

    bufferPot = [[],[],[],[],[]]
    for i in range(40):
        pval = [pot.read() for pot in [pot1, pot2, pot3, pot4, pot5]]
        print(pval[0],pval[1],pval[2],pval[3],pval[4])
        getPots(bufferPot,pval)
        time.sleep_ms(70)

    maxCalibratePots = calcCalibrate(bufferPot)
    print(maxCalibratePots)

    num = 0

    buffer = [[],[],[],[],[],[]]

    for i in range(samples-1):
        getGyro(buffer)
        time.sleep_ms(70)

    gyro, accl = media(buffer)

    limgyro = [[],[],[]]

    holdclick = False

    limpot = [[],[],[],[]]
    triggerPot = [False] * 5
    threshPot = [-120] * 5
    #clickTrigger = threshPot - (threshPot*percentpot)
    #percentpot = 0.1

    # calibrar calibrar
    poragora = 14000

    stepY = 0
    evntTriggeredYP = False
    evntTriggeredYN = False
    thresPercentY = 0.1
    limthresholdYP = poragora 
    limthresholdYN = -poragora
    #limthresholdYP = 14000
    #limthresholdN = -14000
    threshP = limthresholdYP - (limthresholdYP * thresPercentY)
    threshN = limthresholdYN - (limthresholdYN * thresPercentY)

    stepX = 0
    evntTriggeredXP = False
    evntTriggeredXN = False
    thresPercentX = 0.1
    limthresholdXP  = poragora 
    limthresholdXN  = -poragora
    #limthresholdXP = 14000
    #limthresholdXN = -14000
    threshXP = limthresholdXP - (limthresholdXP * thresPercentX)
    threshXN = limthresholdXN - (limthresholdXN * thresPercentX)

    wait2Zero = True
    cycle = 0
    stepWaitXP = 0
    stepWaitXN = 0
    stepWaitYP = 0
    stepWaitYN = 0

    gy1, gy2 = 0, 1 # normal
    #gy1, gy2 = 1, 0 # invertido

    abcR = abc[0]
    abclevel = abcR[0]

    vibrar(2)
    while True:

        #host, msg = e.recv()

        gyro, accl = media(buffer)
        #print(gyro[0],gyro[1],gyro[2])
        #print(accl[0],accl[1],accl[2])
        #print(gyro[0],gyro[1],gyro[2],accl[0],accl[1],accl[2])

        #--------------------------------------------
        if not evntTriggeredXP and not holdclick and gyro[gy1] > threshXP:
            if gy1 == 0: stepX += 1
            if gy1 == 1: stepX -= 1
            vibrar(1,stepX)
            evntTriggeredXP = True
            wait2Zero = False
            cycle = 0

        elif evntTriggeredXP and gyro[gy1] <= threshXP:
            evntTriggeredXP = False
            wait2Zero = True


        if not evntTriggeredXN and not holdclick and gyro[gy1] < threshXN:
            if gy1 == 0: stepX -= 1
            if gy1 == 1: stepX += 1
            vibrar(1,stepX)
            evntTriggeredXN = True
            wait2Zero = False
            cycle = 0

        elif evntTriggeredXN and gyro[gy1] >= threshXN:
            evntTriggeredXN = False
            wait2Zero = True

        if evntTriggeredXP: stepWaitXP += 1
        else: stepWaitXP = 0
        if stepWaitXP >= 5:
            if gy1 == 0: stepX += 1
            if gy1 == 1: stepX -= 1
            stepWaitXP = 0
            vibrar(1,stepX)

        if evntTriggeredXN: stepWaitXN += 1
        else: stepWaitXN = 0
        if stepWaitXN >= 5:
            if gy1 == 0: stepX -= 1
            if gy1 == 1: stepX += 1
            stepWaitXN = 0
            vibrar(1,stepX)
        #--------------------------------------------



        #--------------------------------------------
        if not evntTriggeredYP and not holdclick and gyro[gy2] > threshP:
            if gy2 == 0: stepY -= 1
            if gy2 == 1: stepY += 1
            vibrar(1,stepY)
            evntTriggeredYP = True
            wait2Zero = False
            cycle = 0

        elif evntTriggeredYP and gyro[gy2] <= threshP:
            evntTriggeredYP = False
            wait2Zero = True

        if not evntTriggeredYN and not holdclick and gyro[gy2] < threshN:
            if gy2 == 0: stepY += 1
            if gy2 == 1: stepY -= 1
            vibrar(1,stepY)
            evntTriggeredYN = True
            wait2Zero = False
            cycle = 0

        elif evntTriggeredYN and gyro[gy2] >= threshN:
            evntTriggeredYN = False
            wait2Zero = True
        #--------------------------------------------
        if evntTriggeredYP: stepWaitYP += 1
        else: stepWaitYP = 0
        if stepWaitYP >= 5:
            if gy1 == 0: stepY += 1
            if gy1 == 1: stepY -= 1
            stepWaitYP = 0
            vibrar(1,stepY)

        if evntTriggeredYN: stepWaitYN += 1
        else: stepWaitYN = 0
        if stepWaitYN >= 5:
            if gy1 == 0: stepY -= 1
            if gy1 == 1: stepY += 1
            stepWaitYN = 0
            vibrar(1,stepY)
        #--------------------------------------------

        #print(stepY,stepX,stepWaitXP,stepWaitXN)


        #--------------------------------------------
        #maxCalibratePots
        pval = [pot.read() for pot in [pot1, pot2, pot3, pot4, pot5]]
        #print(pval[0],pval[1],pval[2],pval[3],pval[4])

        for i in range(len(pval)):
            pval[i] = pval[i]-maxCalibratePots[i]

        #print(pval[0],pval[1],pval[2],pval[3],pval[4])
        #pval = [pot.read() for pot in [pot1]]
        #print (pval[0])

        '''
        if num == 0: startlim(limpot, [pval[0],pval[1],pval[2],pval[3]])
        calclim(limpot[0],pval[0])
        calclim(limpot[1],pval[1])
        calclim(limpot[2],pval[2])
        calclim(limpot[3],pval[3])
        print(limpot[0][0],limpot[1][0],limpot[2][0],limpot[3][0])
        '''

        #if num == 0: startlimpot(limpot, [4050, 2800, 2800])

        if stepY == 2 and stepX == -1: abclevel = abcR[0][0]
        elif stepY == 1 and stepX == -1: abclevel = abcR[0][1]
        elif stepY == 0 and stepX == -1: abclevel = abcR[0][2]
        elif stepY == -1 and stepX == -1: abclevel = abcR[0][3]
        elif stepY == -2 and stepX == -1: abclevel = abcR[0][4]

        elif stepY == 2 and stepX == 0: abclevel = abcR[1][0]
        elif stepY == 1 and stepX == 0: abclevel = abcR[1][1]
        elif stepY == 0 and stepX == 0: abclevel = abcR[1][2]
        elif stepY == -1 and stepX == 0: abclevel = abcR[1][3]
        elif stepY == -2 and stepX == 0: abclevel = abcR[1][4]

        elif stepY == 2 and stepX == 1: abclevel = abcR[2][0]
        elif stepY == 1 and stepX == 1: abclevel = abcR[2][1]
        elif stepY == 0 and stepX == 1: abclevel = abcR[2][2]
        elif stepY == -1 and stepX == 1: abclevel = abcR[2][3]
        elif stepY == -2 and stepX == 1: abclevel = abcR[2][4]


        for i in range(5):
            if not triggerPot[i] and pval[i] < threshPot[i]:

                # >>> evento
                #print(i)
                print(stepY,stepX,'\t',abclevel[i],cycle)
                #print(stepY,stepX,'\t',abclevel[i],threshPot[i],pval[i],cycle)

                #send_charPs(abclevel[i], kb)
                send_charPs(abclevel[i], 1, peer)
                triggerPot[i] = True
                holdclick = True
                wait2Zero = False
                cycle = 0

            elif triggerPot[i] and pval[i] >= threshPot[i]:
                #send_charRl(kb)
                send_charPs(abclevel[i], 0, peer)
                triggerPot[i] = False
                holdclick = False
                wait2Zero = True

            #if triggerPot[i]:
            #   print(triggerPot[i])
        
        #--------------------------------------------
        #if msg:
        #    print(msg)


        if wait2Zero: cycle += 1
        if cycle == 20:
            stepY = 0
            stepX = 0
            vibrar(2)

        if num % tclear == 0: num = 0

        num+=1
        time.sleep_ms(tsleep)

'''
def advertising(kb):
    print('\n.......................start_advertising')
    kb.start_advertising()
    while True:
        if kb.get_state() == 3:
            print('tf2kb connected!')
            kb.stop_advertising()
            break
        time.sleep_ms(1000)
        print('...')
'''

#---------------------------------------------------------------
print('\n.......................')
#kb = Keyboard("tf2kb")
#kb.set_state_change_callback(None)
#kb.start()

#advertising(kb)
#kb.get_state()
#1 si kb.get_state() DEVICE_IDLE = desconectado
#2 si kb.get_state() DEVICE_ADVERTISING = disponibilidade
#3 si kb.get_state() DEVICE_CONNECTED = conectaado

#---------------------------------------------------------------
print('\n.......................')
#if kb.get_state() == 3:

from hidcodes import hidcodes, abc 

i2c = SoftI2C(scl=Pin(22), sda=Pin(21))
mpuSensor = mpu6050.accel(i2c)

pino_vibracao = Pin(32, Pin.OUT)

vibrar(4)


'''
pot1 = ADC(Pin(34))
pot2 = ADC(Pin(35))
pot3 = ADC(Pin(32))
pot4 = ADC(Pin(33))
#pot5 = ADC(Pin(39))

pot1.atten(ADC.ATTN_11DB)
pot2.atten(ADC.ATTN_11DB)
pot3.atten(ADC.ATTN_11DB)
pot4.atten(ADC.ATTN_11DB)
#pot5.atten(ADC.ATTN_11DB)
'''

pot5 = TouchPad(Pin(33)) #
pot4 = TouchPad(Pin(13)) #
pot3 = TouchPad(Pin(15)) #
pot2 = TouchPad(Pin(04)) #
pot1 = TouchPad(Pin(27)) #

# ESPNOW - A WLAN interface must be active to send()/recv()
sta = network.WLAN(network.STA_IF)
sta.active(True)
#sta.disconnect()   # Because ESP8266 auto-connects to last Access Point
e = espnow.ESPNow()
e.active(True)
peer = b'\xbb\xbb\xbb\xbb\xbb\xbb' # MAC address of peer's wifi interface
e.add_peer(peer) # Must add_peer() before send()

#---------------------------------------------------------------
TSLEEP=50
TCLEAR=10000
#TCLEAR=10000
SAMPLES = 5 

run(TSLEEP,TCLEAR,SAMPLES,e,peer)










=== ARQUIVO: alesp/no_sue_l/boot.py ===

# This file is executed on every boot (including wake-boot from deepsleep)
#import esp
#esp.osdebug(None)
#import webrepl
#webrepl.start()


=== ARQUIVO: alesp/no_sue_l/mpu6050.py ===

import machine


class accel():
    def __init__(self, i2c, addr=0x68):
        self.iic = i2c
        self.addr = addr
        self.iic.start()
        self.iic.writeto(self.addr, bytearray([107, 0]))
        self.iic.stop()

    def get_raw_values(self):
        self.iic.start()
        a = self.iic.readfrom_mem(self.addr, 0x3B, 14)
        self.iic.stop()
        return a

    def get_ints(self):
        b = self.get_raw_values()
        c = []
        for i in b:
            c.append(i)
        return c

    def bytes_toint(self, firstbyte, secondbyte):
        if not firstbyte & 0x80:
            return firstbyte << 8 | secondbyte
        return - (((firstbyte ^ 255) << 8) | (secondbyte ^ 255) + 1)

    def get_values(self):
        raw_ints = self.get_raw_values()
        vals = {}
        vals["AcX"] = self.bytes_toint(raw_ints[0], raw_ints[1])
        vals["AcY"] = self.bytes_toint(raw_ints[2], raw_ints[3])
        vals["AcZ"] = self.bytes_toint(raw_ints[4], raw_ints[5])
        vals["Tmp"] = self.bytes_toint(raw_ints[6], raw_ints[7]) / 340.00 + 36.53
        vals["GyX"] = self.bytes_toint(raw_ints[8], raw_ints[9])
        vals["GyY"] = self.bytes_toint(raw_ints[10], raw_ints[11])
        vals["GyZ"] = self.bytes_toint(raw_ints[12], raw_ints[13])
        return vals  # returned in range of Int16
        # -32768 to 32767

    def val_test(self):  # ONLY FOR TESTING! Also, fast reading sometimes crashes IIC
        from time import sleep
        while 1:
            print(self.get_values())
            sleep(0.05)
