=== CONSOLIDAÇÃO DE CÓDIGOS DA PASTA: aresp ===



=== ARQUIVO: aresp/config.py ===

# -----------------------------
# CONFIGURAÇÕES DO SISTEMA
# -----------------------------

# Pinos dos touchpads
THIS_IS = 1 # 0=L, 1=R

# Potenciômetros
## Thresholds individuais
THRESH_POT = [-120] * 5 # -50 (muito sensível) e -200 (pouco sensível)
POT_CALIBRATION_SAMPLES = 40 # 20 (rápido) e 100 (preciso)
POT_CALIBRATION_DELAY_MS = 70 # 0ms e 100ms. 70ms permite leituras estáveis

# Giroscópio
## Limite base para thresholds
PORAGORA = 14000        # 8000 (mais sensível) e 20000 (menos sensível)
# Percentual usado para criar thresholds
THRES_PERCENT = 0.1     # 0.05 (5%) e 0.2 (20%). 0.1 (10%)

# Controle de passos automáticos
STEP_WAIT_LIMIT = 5     # Quantos ciclos esperar antes de repetir passo

# Reset
CYCLE_RESET_LIMIT = 20  # Quantos ciclos parado até resetar stepX/stepY

# Loop principal
TSLEEP = 50             # Delay entre loops (ms)
TCLEAR = 10000          # Intervalo para reset de contador
SAMPLES = 5             # Amostras iniciais do giroscópio

# Inverter sentido do eixo X e/ou Y
INVERT_X = True         # True re(+) ar(-) False o contrario
INVERT_Y = True         # True re(+) ar(-) False o contrario

# Ordem dos eixos do giroscópio
GY1, GY2 = 0, 1         # Eixo X primeiro, depois Y

PINOS_R = 13,12,14,27,4
INDEX_MAP_R = 0,1,2,3,4
PINOS_VIB_R = 33

PINOS_L = 12,13,14,27,4
INDEX_MAP_L = 0,1,2,3,4
PINOS_VIB_L = 32


# -----------------------------
# DEBUG
# -----------------------------
DEBUG = 0
"""
| Você Quer...                  | Configuração        | Comportamento          |
|-------------------------------|---------------------|------------------------|
| Só logs de nível X            | `DEBUG = X`         | Ignora tudo ≠ X        |
| Todos os logs                 | `DEBUG = None`      | Mostra tudo            |
| Logs sem nível                | `DEBUG = -1`        | Mostra só os sem nível |
| Múltiplos níveis (ex: 0,1,2)  | `DEBUG = [0, 1, 2]` | Mostra só esses níveis |
"""




=== ARQUIVO: aresp/actions.py ===

from machine import Pin, UART
import time

# UART - ajuste TX e RX conforme o seu hardware
uart = UART(1, baudrate=115200, tx=17, rx=16)

def send_charPs(zmkcodes):
    if zmkcodes is not None:
        print(zmkcodes)
        row = zmkcodes[0]
        col = zmkcodes[1]
        if zmkcodes[2] == 0:
            event_type = 0x01
        else:
            event_type = 0x00
        checksum = event_type ^ row ^ col
        packet = bytes([0xAA, event_type, row, col, checksum])
        # print(packet)
        uart.write(packet)


def vibrar(pino_vibracao, n_pulsos, step=None):
    if pino_vibracao is None:
        print("vibrador não inicializado")
        return
    for _ in range(n_pulsos):
        try:
            pino_vibracao.on()
        except Exception:
            # alguns firmwares usam value(1)/value(0)
            try: pino_vibracao.value(1)
            except: pass
        if step == 0:
            time.sleep_ms(200)
        else:
            time.sleep_ms(101)
        try:
            pino_vibracao.off()
        except Exception:
            try: pino_vibracao.value(0)
            except: pass
        time.sleep_ms(70)



=== ARQUIVO: aresp/hw.py ===

from machine import Pin, SoftI2C, TouchPad
import time
import config

if config.THIS_IS == 1:
    pinos = config.PINOS_R
    pinos_vib = config.PINOS_VIB_R

if config.THIS_IS == 0:
    pinos = config.PINOS_L
    pinos_vib = config.PINOS_VIB_L

def init_i2c(scl_pin=22, sda_pin=21):
    return SoftI2C(scl=Pin(scl_pin), sda=Pin(sda_pin))

def init_mpu(i2c):
    # importa aqui para evitar erro se rodar testes sem MPU
    try:
        import mpu6050
        mpu = mpu6050.MPU6050(i2c)
        return mpu
    except Exception as e:
        print("init_mpu erro:", e)
        return None

def init_vibrator(pin_no=(pinos_vib)):
    p = Pin(pin_no, Pin.OUT)
    try:
        p.off()
    except Exception:
        pass
    return p

def init_pots(pins=(pinos)):
    return [TouchPad(Pin(p)) for p in pins]

# teste rápido:
if __name__ == "__main__":
    i2c = init_i2c()
    mpu = init_mpu(i2c)
    vib = init_vibrator()
    pots = init_pots()
    print("hw init done, mpu:", bool(mpu), "pots:", [type(p) for p in pots])


=== ARQUIVO: aresp/dicctozmk.py ===



# --- Mapas de tradução (lado esquerdo e lado direito) ---

## M=Moto, Y=Yave [M,Y]
## pot [gx, gy] status [M,Y]

MAPL = {
    # abclevel, gx, gy: (row, col)

    # --- Gyro (1,0) [M,T] ---
    (0,  1,  0): (3, 5),  # space
    (1,  1,  0): (0, 1),  # q
    (2,  1,  0): (0, 2),  # w
    (3,  1,  0): (0, 3),  # e
    (4,  1,  0): (0, 4),  # r

    # --- Gyro (0,0) [M,T] ---
    (0,  0,  0): (3, 5),  # space
    (1,  0,  0): (1, 1),  # a
    (2,  0,  0): (1, 2),  # s
    (3,  0,  0): (1, 3),  # d
    (4,  0,  0): (1, 4),  # f

    # --- Gyro (-1,0) [M,T] ---
    (0, -1,  0): (3, 5),  # space
    (1, -1,  0): (2, 1),  # z
    (2, -1,  0): (2, 2),  # x
    (3, -1,  0): (2, 3),  # c
    (4, -1,  0): (2, 4),  # v

    # --- Gyro (1,1) [M,T] ---
    (0,  1,  1): (3, 5),  # space
    (1,  1,  1): (1, 5),  # t
    (4,  1,  1): (0, 0),  # esc

    # --- Gyro (0,1) [M,T] ---
    (0,  0,  1): (3, 5),  # space
    (1,  0,  1): (1, 5),  # g
    (4,  0,  1): (0, 0),  # esc

    # --- Gyro (-1,1) [M,T] ---
    (0, -1,  1): (3, 5),  # space
    (1, -1,  1): (1, 5),  # b
    (4, -1,  1): (0, 0),  # esc
}

MAPR = {
    # --- Gyro (1,1) [M,T] ---
    (0,  1,  1): (3, 6),   # space
    (1,  1,  1): (1, 6),   # y
    (4,  1,  1): (12, 0),  # backspace

    # --- Gyro (0,1) [M,T] ---
    (0,  1,  0): (3, 6),   # space
    (1,  1,  0): (1, 6),   # h
    (4,  1,  0): (12, 0),  # enter

    # --- Gyro (-1,1) [M,T] ---
    (0,  1, -1): (3, 6),   # space
    (1,  1, -1): (1, 6),   # n
    (4,  1, -1): (12, 0),  # ctrl

    # --- Gyro (1,0) [M,T] ---
    (0,  1,  0): (3, 6),   # space
    (1,  1,  0): (1, 7),   # u
    (2,  1,  0): (1, 8),   # i
    (3,  1,  0): (1, 9),   # o
    (4,  1,  0): (1, 10),   # p

    # --- Gyro (0,0) [M,T] ---
    (0,  0,  0): (3, 6),   # space
    (1,  0,  0): (0, 7),   # j
    (2,  0,  0): (0, 8),   # k
    (3,  0,  0): (0, 9),   # l
    (4,  0,  0): (0, 10),   # c

    # --- Gyro (-1,0) [M,T] ---
    (0, -1,  0): (3, 6),   # space
    (1, -1,  0): (-1, 7),  # m
    (2, -1,  0): (-1, 8),  # ,
    (3, -1,  0): (-1, 9),  # .
    (4, -1,  0): (-1, 10),  # ;
}

def potsgyrotozmk(abclevel, mapped_i, status, side):
    """
    Traduz (abclevel, gx, gy, status) -> (row, col, status)
    side: 0 = left, 1 = right
    """
    mapping = MAPL if side == 0 else MAPR
    key = (mapped_i, abclevel[0], abclevel[1])
    if key not in mapping:
        return None  # tecla não mapeada
    row, col = mapping[key]
    return row, col, status



=== ARQUIVO: aresp/pots.py ===

def add_pot_samples(bufferPot, pval):
    """bufferPot: list de listas; pval: lista com leituras atuais"""
    for i, v in enumerate(pval):
        bufferPot[i].append(v)
    return bufferPot

def calc_calibrate(bufferPot):
    """Retorna lista com max por pot (ou 0 se vazio)"""
    maxCalc = []
    for potList in bufferPot:
        maxCalc.append(max(potList) if potList else 0)
    return maxCalc


=== ARQUIVO: aresp/gyro.py ===

def append_gyro(buffer, mpuSensor):
    """Adiciona uma leitura ao buffer (6 listas)"""
    if mpuSensor is None:
        # evita crash se MPU não inicializou
        return buffer
    try:
        mpuData = mpuSensor.get_values()
    except Exception as e:
        print("MPU read error:", e)
        return buffer

    keys = ['GyX','GyY','GyZ','AcX','AcY','AcZ']
    for i, k in enumerate(keys):
        buffer[i].append(mpuData.get(k, 0))
    return buffer

def average_and_slide(buffer, mpuSensor):
    """Lê mais um valor, calcula média e remove o mais antigo (sliding window)"""
    append_gyro(buffer, mpuSensor)
    averages = []
    for lst in buffer:
        averages.append(sum(lst)/len(lst) if lst else 0)
    gyro = averages[:3]
    accl = averages[3:6]
    # remove o mais antigo para manter a janela
    for lst in buffer:
        if lst:
            lst.pop(0)
    return gyro, accl


=== ARQUIVO: aresp/mpu6050.py ===

import machine

class MPU6050():
    def __init__(self, i2c, addr=0x68):
        self.iic = i2c
        self.addr = addr
        self.iic.start()
        self.iic.writeto(self.addr, bytearray([107, 0]))
        self.iic.stop()

    def get_raw_values(self):
        self.iic.start()
        a = self.iic.readfrom_mem(self.addr, 0x3B, 14)
        self.iic.stop()
        return a

    def get_ints(self):
        b = self.get_raw_values()
        c = []
        for i in b:
            c.append(i)
        return c

    def bytes_toint(self, firstbyte, secondbyte):
        if not firstbyte & 0x80:
            return firstbyte << 8 | secondbyte
        return - (((firstbyte ^ 255) << 8) | (secondbyte ^ 255) + 1)

    def get_values(self):
        raw_ints = self.get_raw_values()
        vals = {}
        vals["AcX"] = self.bytes_toint(raw_ints[0], raw_ints[1])
        vals["AcY"] = self.bytes_toint(raw_ints[2], raw_ints[3])
        vals["AcZ"] = self.bytes_toint(raw_ints[4], raw_ints[5])
        vals["Tmp"] = self.bytes_toint(raw_ints[6], raw_ints[7]) / 340.00 + 36.53
        vals["GyX"] = self.bytes_toint(raw_ints[8], raw_ints[9])
        vals["GyY"] = self.bytes_toint(raw_ints[10], raw_ints[11])
        vals["GyZ"] = self.bytes_toint(raw_ints[12], raw_ints[13])
        return vals  # returned in range of Int16
        # -32768 to 32767

    def val_test(self):  # ONLY FOR TESTING! Also, fast reading sometimes crashes IIC
        from time import sleep
        while 1:
            print(self.get_values())
            sleep(0.05)



=== ARQUIVO: aresp/main.py ===

import time
import math
import config
from hw import init_i2c, init_mpu, init_vibrator, init_pots
from actions import vibrar, send_charPs
from pots import add_pot_samples, calc_calibrate
from gyro import append_gyro, average_and_slide
from dicctozmk import potsgyrotozmk

if config.THIS_IS == 1:
    INDEX_MAP_POTS = list(config.INDEX_MAP_R)

if config.THIS_IS == 0:
    INDEX_MAP_POTS = list(config.INDEX_MAP_L)

# -----------------------------
# Função de log centralizada
# -----------------------------
def log(*args, **kwargs):
    level = None  # Sem nível por padrão
    if len(args) > 1 and isinstance(args[1], int) and args[1] >= 0:
        level = args[1]
        args = (args[0],) + args[2:]  # Remove o level dos args
    
    debug_level = getattr(config, 'DEBUG', None)
    
    if debug_level is not None and level is not None and level != debug_level:
        return
    
    if debug_level is not None and level is None:
        return
    
    print(*args, **kwargs)

# -----------------------------
# Funções auxiliares
# -----------------------------
def calibrate_pots(pots):
    bufferPot = [[] for _ in pots]
    for _ in range(config.POT_CALIBRATION_SAMPLES):
        pval = [pot.read() for pot in pots]
        log("pot sample:", 0, pval)
        add_pot_samples(bufferPot, pval)
        time.sleep_ms(config.POT_CALIBRATION_DELAY_MS)
    log('run...', 0)
    return calc_calibrate(bufferPot)

def check_gyro_axis(axis_index, pos_thresh, neg_thresh, step, event_pos, event_neg, vib, invert=False):
    """Verifica giroscópio em um eixo e atualiza estado."""
    if not event_pos and gyro[axis_index] > pos_thresh:
        step += -1 if invert else 1
        vibrar(vib, 1, step)
        log(f"[GYRO] Eixo {axis_index} POS -> step={step}")
        event_pos = True
    elif event_pos and gyro[axis_index] <= pos_thresh:
        event_pos = False

    if not event_neg and gyro[axis_index] < neg_thresh:
        step += 1 if invert else -1
        vibrar(vib, 1, step)
        log(f"[GYRO] Eixo {axis_index} NEG -> step={step}")
        event_neg = True
    elif event_neg and gyro[axis_index] >= neg_thresh:
        event_neg = False

    return step, event_pos, event_neg

def check_step_wait(event_triggered, step_wait, step, delta, vib):
    """Controle de espera para repetição automática."""
    step_wait = step_wait + 1 if event_triggered else 0
    if step_wait >= config.STEP_WAIT_LIMIT:
        step += delta
        vibrar(vib, 1, step)
        log(f"[STEP_WAIT] step={step} delta={delta}")
        step_wait = 0
    return step_wait, step

def check_pots(pvals, thresh, triggerPot, abclevel, holdclick, wait2Zero, cycle):
    """Verifica potenciômetros e envia eventos."""
    for i, val in enumerate(pvals):
        mapped_i = INDEX_MAP_POTS[i]  # pega índice lógico desejado

        if not triggerPot[i] and val < thresh[i]:
            send_charPs(potsgyrotozmk(abclevel, mapped_i, 1, config.THIS_IS))
            log(f"[POT{mapped_i}] Pressionado | val={val} | abclevel={abclevel}",2)
            triggerPot[i] = True
            holdclick = True
            wait2Zero = False
            cycle = 0

        elif triggerPot[i] and val >= thresh[i]:
            send_charPs(potsgyrotozmk(abclevel, mapped_i, 0, config.THIS_IS))
            log(f"[POT{mapped_i}] Pressionado | val={val} | abclevel={abclevel}",2)
            triggerPot[i] = False
            holdclick = False
            wait2Zero = True

    return triggerPot, holdclick, wait2Zero, cycle

# -----------------------------
# Função principal
# -----------------------------
def start(i2c=None, mpu=None, pots=None, vib=None):
    # Inicializa hardware se não passado
    if i2c is None: i2c = init_i2c()
    if mpu is None: mpu = init_mpu(i2c)
    if vib is None: vib = init_vibrator()
    if pots is None: pots = init_pots()
    pot1, pot2, pot3, pot4, pot5 = pots

    # Calibração de pots
    maxCalibratePots = calibrate_pots(pots)
    log("maxCalibratePots:", maxCalibratePots)

    # Prepara buffer do gyro
    buffer = [[] for _ in range(6)]
    for _ in range(config.SAMPLES - 1):
        append_gyro(buffer, mpu)
        time.sleep_ms(70)
    global gyro
    gyro, accl = average_and_slide(buffer, mpu)

    # Variáveis de estado
    num = 0
    holdclick = False
    triggerPot = [False] * 5
    threshPot = config.THRESH_POT

    # Thresholds giroscópio
    threshP  = config.PORAGORA - (config.PORAGORA * config.THRES_PERCENT)
    threshN  = -config.PORAGORA + (config.PORAGORA * config.THRES_PERCENT)
    threshXP = config.PORAGORA - (config.PORAGORA * config.THRES_PERCENT)
    threshXN = -config.PORAGORA + (config.PORAGORA * config.THRES_PERCENT)

    stepX = stepY = 0
    evntTriggeredXP = evntTriggeredXN = False
    evntTriggeredYP = evntTriggeredYN = False

    wait2Zero = True
    cycle = 0
    stepWaitXP = stepWaitXN = stepWaitYP = stepWaitYN = 0

    gy1, gy2 = config.GY1, config.GY2

    vibrar(vib, 2)

    # Loop principal
    while True:
        gyro, accl = average_and_slide(buffer, mpu)

        # Movimento no eixo X
        stepX, evntTriggeredXP, evntTriggeredXN = check_gyro_axis(
            gy1, threshXP, threshXN, stepX, evntTriggeredXP, evntTriggeredXN, vib, invert=config.INVERT_X
        )

        # Movimento no eixo Y
        stepY, evntTriggeredYP, evntTriggeredYN = check_gyro_axis(
            gy2, threshP, threshN, stepY, evntTriggeredYP, evntTriggeredYN, vib, invert=config.INVERT_Y
        )

        # Controle de repetição automática
        invX = -1 if config.INVERT_X else 1
        invY = -1 if config.INVERT_Y else 1

        stepWaitXP, stepX = check_step_wait(evntTriggeredXP, stepWaitXP, stepX, invX * (1 if gy1 == 0 else -1), vib)
        stepWaitXN, stepX = check_step_wait(evntTriggeredXN, stepWaitXN, stepX, invX * (-1 if gy1 == 0 else 1), vib)
        stepWaitYP, stepY = check_step_wait(evntTriggeredYP, stepWaitYP, stepY, invY * (-1 if gy1 == 0 else 1), vib)
        stepWaitYN, stepY = check_step_wait(evntTriggeredYN, stepWaitYN, stepY, invY * (1 if gy1 == 0 else -1), vib)

        # Leitura dos potenciômetros
        pval = [pot.read() - maxCalibratePots[i] for i, pot in enumerate([pot1, pot2, pot3, pot4, pot5])]
        log(f"[POT VALS] {pval}", 2)

        abclevel = [stepX,stepY]

        # Eventos de pots
        triggerPot, holdclick, wait2Zero, cycle = check_pots(
            pval, threshPot, triggerPot, abclevel, holdclick, wait2Zero, cycle
        )

        # Reset se parado
        if wait2Zero:
            cycle += 1
        if cycle == config.CYCLE_RESET_LIMIT:
            stepY = stepX = 0
            vibrar(vib, 2)
            log("[RESET] StepX e StepY resetados")

        if num % config.TCLEAR == 0:
            num = 0
        num += 1
        time.sleep_ms(config.TSLEEP)

# -----------------------------
# def run():
#     vibrar(init_vibrator(), 4)
#     start()

start()
vibrar(init_vibrator(), 4)


=== ARQUIVO: aresp/no_use_r/hidcodes.py ===

abc=[
        [
            [
                ['','','','KEY_5','KEY_SPACE'],
                ['','','','KEY_T','KEY_SPACE'],
                ['KEY_ESC','KEY_RSHIFT','','KEY_G','KEY_SPACE'],
                ['','','','KEY_B','KEY_SPACE'],
                ['','','','','KEY_SPACE'],
            ],
            [
                ['KEY_1','KEY_2','KEY_3','KEY_4','KEY_SPACE'],
                ['KEY_Q','KEY_W','KEY_E','KEY_R','KEY_SPACE'],
                ['KEY_A','KEY_S','KEY_D','KEY_F','KEY_SPACE'],
                ['KEY_Z','KEY_X','KEY_C','KEY_V','KEY_SPACE'],
                ['','','','','KEY_SPACE'],
            ],
            [
                ['KEY_GRAVE','','','','KEY_SPACE'],
                ['KEY_TAB','','','','KEY_SPACE'],
                ['KEY_CAPSLOCK','','','','KEY_SPACE'],
                ['KEY_LSHIFT','','','','KEY_SPACE'],
                ['KEY_LCTRL','','','KEY_LALT','KEY_SPACE'],
            ],
        ],
        [
            [
                ['KEY_SPACE','KEY_6','','',''],
                ['KEY_SPACE','KEY_Y','','','KEY_DELETE'],
                ['KEY_SPACE','KEY_H','KEY_ENTER','KEY_RSHIFT','KEY_BACKSPACE'],
                ['KEY_SPACE','KEY_N','','',''],
                ['KEY_SPACE','','','',''],
            ],
            [
                ['KEY_SPACE','KEY_7','KEY_8','KEY_9','KEY_0'],
                ['KEY_SPACE','KEY_U','KEY_I','KEY_O','KEY_P'],
                ['KEY_SPACE','KEY_J','KEY_K','KEY_L','KEY_SEMICOLON'],
                ['KEY_SPACE','KEY_M','KEY_COMMA','KEY_DOT','KEY_SLASH'],
                ['KEY_SPACE','KEY_RALT','KEY_RCTRL','',''],
            ],
            [
                ['KEY_SPACE','','KEY_KPMINUS','KEY_KPPLUS','KEY_BACKSPACE'],
                ['KEY_SPACE','','KEY_LEFTBRACE','KEY_RIGHTBRACE','KEY_BACKSLASH'],
                ['KEY_SPACE','','KEY_SEMICOLON','KEY_APOSTROPHE','KEY_ENTER'],
                ['KEY_SPACE','KEY_COMMA','KEY_DOT','KEY_SLASH','KEY_RSHIFT'],
                ['KEY_SPACE','','','',''],
            ],
        ],
    ]

hidcodes = {
    "KEY_NONE": 0x00,
    "KEY_ERR_OVF": 0x01,
    "KEY_A": 0x04,
    "KEY_B": 0x05,
    "KEY_C": 0x06,
    "KEY_D": 0x07,
    "KEY_E": 0x08,
    "KEY_F": 0x09,
    "KEY_G": 0x0a,
    "KEY_H": 0x0b,
    "KEY_I": 0x0c,
    "KEY_J": 0x0d,
    "KEY_K": 0x0e,
    "KEY_L": 0x0f,
    "KEY_M": 0x10,
    "KEY_N": 0x11,
    "KEY_O": 0x12,
    "KEY_P": 0x13,
    "KEY_Q": 0x14,
    "KEY_R": 0x15,
    "KEY_S": 0x16,
    "KEY_T": 0x17,
    "KEY_U": 0x18,
    "KEY_V": 0x19,
    "KEY_W": 0x1a,
    "KEY_X": 0x1b,
    "KEY_Y": 0x1c,
    "KEY_Z": 0x1d,
    "KEY_1": 0x1e,
    "KEY_2": 0x1f,
    "KEY_3": 0x20,
    "KEY_4": 0x21,
    "KEY_5": 0x22,
    "KEY_6": 0x23,
    "KEY_7": 0x24,
    "KEY_8": 0x25,
    "KEY_9": 0x26,
    "KEY_0": 0x27,
    "KEY_ENTER": 0x28,
    "KEY_ESC": 0x29,
    "KEY_BACKSPACE": 0x2a,
    "KEY_TAB": 0x2b,
    "KEY_SPACE": 0x2c,
    "KEY_MINUS": 0x2d,
    "KEY_EQUAL": 0x2e,
    "KEY_LEFTBRACE": 0x2f,
    "KEY_RIGHTBRACE": 0x30,
    "KEY_BACKSLASH": 0x31,
    "KEY_HASHTILDE": 0x32,
    "KEY_SEMICOLON": 0x33,
    "KEY_APOSTROPHE": 0x34,
    "KEY_GRAVE": 0x35,
    "KEY_COMMA": 0x36,
    "KEY_DOT": 0x37,
    "KEY_SLASH": 0x38,
    "KEY_CAPSLOCK": 0x39,
    "KEY_F1": 0x3a,
    "KEY_F2": 0x3b,
    "KEY_F3": 0x3c,
    "KEY_F4": 0x3d,
    "KEY_F5": 0x3e,
    "KEY_F6": 0x3f,
    "KEY_F7": 0x40,
    "KEY_F8": 0x41,
    "KEY_F9": 0x42,
    "KEY_F10": 0x43,
    "KEY_F11": 0x44,
    "KEY_F12": 0x45,
    "KEY_SYSRQ": 0x46,
    "KEY_SCROLLLOCK": 0x47,
    "KEY_PAUSE": 0x48,
    "KEY_INSERT": 0x49,
    "KEY_HOME": 0x4a,
    "KEY_PAGEUP": 0x4b,
    "KEY_DELETE": 0x4c,
    "KEY_END": 0x4d,
    "KEY_PAGEDOWN": 0x4e,
    "KEY_RIGHT": 0x4f,
    "KEY_LEFT": 0x50,
    "KEY_DOWN": 0x51,
    "KEY_UP": 0x52,
    "KEY_NUMLOCK": 0x53,
    "KEY_KPSLASH": 0x54,
    "KEY_KPASTERISK": 0x55,
    "KEY_KPMINUS": 0x56,
    "KEY_KPPLUS": 0x57,
    "KEY_KPENTER": 0x58,
    "KEY_KP1": 0x59,
    "KEY_KP2": 0x5a,
    "KEY_KP3": 0x5b,
    "KEY_KP4": 0x5c,
    "KEY_KP5": 0x5d,
    "KEY_KP6": 0x5e,
    "KEY_KP7": 0x5f,
    "KEY_KP8": 0x60,
    "KEY_KP9": 0x61,
    "KEY_KP0": 0x62,
    "KEY_KPDOT": 0x63,
    "KEY_102ND": 0x64,
    "KEY_COMPOSE": 0x65,
    "KEY_POWER": 0x66,
    "KEY_KPEQUAL": 0x67,
    "KEY_F13": 0x68,
    "KEY_F14": 0x69,
    "KEY_F15": 0x6a,
    "KEY_F16": 0x6b,
    "KEY_F17": 0x6c,
    "KEY_F18": 0x6d,
    "KEY_F19": 0x6e,
    "KEY_F20": 0x6f,
    "KEY_F21": 0x70,
    "KEY_F22": 0x71,
    "KEY_F23": 0x72,
    "KEY_F24": 0x73,
    "KEY_OPEN": 0x74,
    "KEY_HELP": 0x75,
    "KEY_PROPS": 0x76,
    "KEY_FRONT": 0x77,
    "KEY_STOP": 0x78,
    "KEY_AGAIN": 0x79,
    "KEY_UNDO": 0x7a,
    "KEY_CUT": 0x7b,
    "KEY_COPY": 0x7c,
    "KEY_PASTE": 0x7d,
    "KEY_FIND": 0x7e,
    "KEY_MUTE": 0x7f,
    "KEY_VOLUMEUP": 0x80,
    "KEY_VOLUMEDOWN": 0x81,
    "KEY_MEDIA_PLAYPAUSE": 0xe8,
    "KEY_MEDIA_STOPCD": 0xe9,
    "KEY_MEDIA_PREVIOUSSONG": 0xea,
    "KEY_MEDIA_NEXTSONG": 0xeb,
    "KEY_MEDIA_EJECTCD": 0xec,
    "KEY_MEDIA_VOLUMEUP": 0xed,
    "KEY_MEDIA_VOLUMEDOWN": 0xee,
    "KEY_MEDIA_MUTE": 0xef,
    "KEY_MEDIA_WWW": 0xf0,
    "KEY_MEDIA_BACK": 0xf1,
    "KEY_MEDIA_FORWARD": 0xf2,
    "KEY_MEDIA_STOP": 0xf3,
    "KEY_MEDIA_FIND": 0xf4,
    "KEY_MEDIA_SCROLLUP": 0xf5,
    "KEY_MEDIA_SCROLLDOWN": 0xf6,
    "KEY_MEDIA_EDIT": 0xf7,
    "KEY_MEDIA_SLEEP": 0xf8,
    "KEY_MEDIA_COFFEE": 0xf9,
    "KEY_MEDIA_REFRESH": 0xfa,
    "KEY_MEDIA_CALC": 0xfb
}


=== ARQUIVO: aresp/no_use_r/txt_allfiles.txt ===

=== CONSOLIDAÇÃO DE CÓDIGOS DA PASTA: use ===



=== ARQUIVO: use/hardware.py ===

from machine import Pin, SoftI2C, TouchPad
import mpu6050

def init_hardware():
    i2c = SoftI2C(scl=Pin(22), sda=Pin(21))
    mpuSensor = mpu6050.accel(i2c)

    pino_vibracao = Pin(33, Pin.OUT)

    pots = [
        TouchPad(Pin(13)),
        TouchPad(Pin(12)),
        TouchPad(Pin(14)),
        TouchPad(Pin(27)),
        TouchPad(Pin(4)),
    ]
    return pots, mpuSensor, pino_vibracao


=== ARQUIVO: use/actions.py ===

import time

def vibrar(pino, n_pulsos, step=None):
    if not hasattr(pino, 'on') or not hasattr(pino, 'off'):
        raise TypeError("O parâmetro 'pino' precisa ser um objeto Pin com métodos 'on' e 'off'.")
    for _ in range(n_pulsos):
        pino.on()
        if step == 0:
            time.sleep_ms(200)
        else:
            time.sleep_ms(101)
        pino.off()
        time.sleep_ms(70)

def send_charPs(abckey):
    print(f"TOQUE DETECTADO! Nível: {abckey}")


=== ARQUIVO: use/utils.py ===

import time

def media(valores):
    return sum(valores) / len(valores) if valores else 0

def calibrar_touchpads(pots, amostras=40, delay_ms=70):
    buffers = [[] for _ in pots]
    for _ in range(amostras):
        leituras = [p.read() for p in pots]
        for i, leitura in enumerate(leituras):
            buffers[i].append(leitura)
        time.sleep_ms(delay_ms)

    maximos = [max(b) for b in buffers]
    return maximos


=== ARQUIVO: use/sensors.py ===

import time
from utils import calibrar_touchpads
from actions import vibrar, send_charPs

def check_sensor(value, thresh_pos, state, name):
    if value < thresh_pos and not state["trigger"]:
        state["trigger"] = True
        print(f"[{name}] Toque detectado! Valor: {value}")
        if state["action"]:
            state["action"](state)  # Acho que você quis executar a ação aqui
    elif value >= thresh_pos and state["trigger"]:
        state["trigger"] = False
    return state

def start_sensors(pots, mpuSensor, pino_vibracao, tsleep, tclear, samples):
    import actions
    actions.pino_vibracao = pino_vibracao

    print("Calibrando touchpads...")
    maxCalibratePots = calibrar_touchpads(pots)
    thresholds = [m - 100 for m in maxCalibratePots]

    sensors = []
    for i, pot in enumerate(pots):
        sensors.append({
            "name": f"pot{i+1}",
            "read": lambda p=pot: p.read(),
            "thresh_pos": thresholds[i],
            "trigger": False,
            "action": lambda s, i=i: send_charPs(f"Pot {i+1}")  # Corrigido para captura correta do i
        })

    vibrar(pino_vibracao, 2)  # Passando o pino corretamente
    print("Sistema iniciado. Toque para testar...")

    while True:
        for sensor in sensors:
            val = sensor["read"]()
            sensor.update(check_sensor(val, sensor["thresh_pos"], sensor, sensor["name"]))
        time.sleep_ms(tsleep)


=== ARQUIVO: use/mpu6050.py ===

import machine

class accel():
    def __init__(self, i2c, addr=0x68):
        self.iic = i2c
        self.addr = addr
        self.iic.start()
        self.iic.writeto(self.addr, bytearray([107, 0]))
        self.iic.stop()

    def get_raw_values(self):
        self.iic.start()
        a = self.iic.readfrom_mem(self.addr, 0x3B, 14)
        self.iic.stop()
        return a

    def get_ints(self):
        b = self.get_raw_values()
        c = []
        for i in b:
            c.append(i)
        return c

    def bytes_toint(self, firstbyte, secondbyte):
        if not firstbyte & 0x80:
            return firstbyte << 8 | secondbyte
        return - (((firstbyte ^ 255) << 8) | (secondbyte ^ 255) + 1)

    def get_values(self):
        raw_ints = self.get_raw_values()
        vals = {}
        vals["AcX"] = self.bytes_toint(raw_ints[0], raw_ints[1])
        vals["AcY"] = self.bytes_toint(raw_ints[2], raw_ints[3])
        vals["AcZ"] = self.bytes_toint(raw_ints[4], raw_ints[5])
        vals["Tmp"] = self.bytes_toint(raw_ints[6], raw_ints[7]) / 340.00 + 36.53
        vals["GyX"] = self.bytes_toint(raw_ints[8], raw_ints[9])
        vals["GyY"] = self.bytes_toint(raw_ints[10], raw_ints[11])
        vals["GyZ"] = self.bytes_toint(raw_ints[12], raw_ints[13])
        return vals  # returned in range of Int16
        # -32768 to 32767

    def val_test(self):  # ONLY FOR TESTING! Also, fast reading sometimes crashes IIC
        from time import sleep
        while 1:
            print(self.get_values())
            sleep(0.05)



=== ARQUIVO: use/main.py ===

from hardware import init_hardware
from actions import vibrar
from sensors import start_sensors

def main():
    TSLEEP = 50
    TCLEAR = 10000
    SAMPLES = 5
    
    pots, mpuSensor, pino_vibracao = init_hardware()
    vibrar(pino_vibracao, 4)  # Passa o pino
    start_sensors(pots, mpuSensor, pino_vibracao, TSLEEP, TCLEAR, SAMPLES)


=== ARQUIVO: aresp/no_use_r/bkpmain.py ===

import time
import math
import mpu6050
from machine import Pin, SoftI2C, ADC, TouchPad

print()
print('*********************************')

def send_charPs(abckey):
    print(abckey)

def vibrar(n_pulsos, step=None):
    for _ in range(n_pulsos):
        pino_vibracao.on()
        if step == 0:
            time.sleep_ms(200)
        else:
            #time.sleep_ms(70)
            time.sleep_ms(101)
        #time.sleep_ms(200)
        pino_vibracao.off()
        time.sleep_ms(70)

def calclim(lim,val):
    lst = (lim[0],lim[1],val)
    lim[0] = max(lst)
    lim[1] = min(lst)
    lim[2] = val
    return lim 

def getPots(bufferPot,pval):
    bufferPot[0].append(pval[0])
    bufferPot[1].append(pval[1])
    bufferPot[2].append(pval[2])
    bufferPot[3].append(pval[3])
    bufferPot[4].append(pval[4])
    return bufferPot

def calcCalibrate(bufferPot):
    maxCalc = [] 
    for potList in bufferPot:
        maxCalc.append(max(potList))
    return maxCalc


def getGyro(buffer):
    mpuData = mpuSensor.get_values()
    buffer[0].append(mpuData['GyX'])
    buffer[1].append(mpuData['GyY'])
    buffer[2].append(mpuData['GyZ'])
    buffer[3].append(mpuData['AcX'])
    buffer[4].append(mpuData['AcY'])
    buffer[5].append(mpuData['AcZ'])
    return buffer

def media(buffer):
    getGyro(buffer)
    xgyro = sum(buffer[0])/len(buffer[0])
    ygyro = sum(buffer[1])/len(buffer[1])
    zgyro = sum(buffer[2])/len(buffer[2])
    xaccl = sum(buffer[3])/len(buffer[3])
    yaccl = sum(buffer[4])/len(buffer[4])
    zaccl = sum(buffer[5])/len(buffer[5])
    gyro = [xgyro,ygyro,zgyro]
    accl = [xaccl,yaccl,zaccl]
    buffer[0].pop(0)
    buffer[1].pop(0)
    buffer[2].pop(0)
    buffer[3].pop(0)
    buffer[4].pop(0)
    buffer[5].pop(0)
    return gyro,accl

def startlim(arrlim,vals):
    for i in range(len(arrlim)):
        arrlim[i] = [vals[i]] * 3
    return arrlim

def startlimpot(arrlim,vals):
    for i in range(len(arrlim)):
        arrlim[i] = vals
    return arrlim

def run(tsleep,tclear,samples):

    bufferPot = [[],[],[],[],[]]
    for i in range(40):
        pval = [pot.read() for pot in [pot1, pot2, pot3, pot4, pot5]]
        print(pval[0],pval[1],pval[2],pval[3],pval[4])
        getPots(bufferPot,pval)
        time.sleep_ms(70)

    maxCalibratePots = calcCalibrate(bufferPot)
    print(maxCalibratePots)

    num = 0

    buffer = [[],[],[],[],[],[]]

    for i in range(samples-1):
        getGyro(buffer)
        time.sleep_ms(70)

    gyro, accl = media(buffer)

    limgyro = [[],[],[]]

    holdclick = False

    limpot = [[],[],[],[]]
    triggerPot = [False] * 5
    threshPot = [-120] * 5
    #clickTrigger = threshPot - (threshPot*percentpot)
    #percentpot = 0.1

    # calibrar calibrar
    poragora = 14000

    stepY = 0
    evntTriggeredYP = False
    evntTriggeredYN = False
    thresPercentY = 0.1
    limthresholdYP = poragora 
    limthresholdYN = -poragora
    #limthresholdYP = 14000
    #limthresholdN = -14000
    threshP = limthresholdYP - (limthresholdYP * thresPercentY)
    threshN = limthresholdYN - (limthresholdYN * thresPercentY)

    stepX = 0
    evntTriggeredXP = False
    evntTriggeredXN = False
    thresPercentX = 0.1
    limthresholdXP  = poragora 
    limthresholdXN  = -poragora
    #limthresholdXP = 14000
    #limthresholdXN = -14000
    threshXP = limthresholdXP - (limthresholdXP * thresPercentX)
    threshXN = limthresholdXN - (limthresholdXN * thresPercentX)

    wait2Zero = True
    cycle = 0
    stepWaitXP = 0
    stepWaitXN = 0
    stepWaitYP = 0
    stepWaitYN = 0

    gy1, gy2 = 0, 1 # normal
    #gy1, gy2 = 1, 0 # invertido

    abcR = abc[1]
    abclevel = abcR[0]

    vibrar(2)
    while True:

        gyro, accl = media(buffer)
        #print(gyro[0],gyro[1],gyro[2])
        #print(accl[0],accl[1],accl[2])
        #print(gyro[0],gyro[1],gyro[2],accl[0],accl[1],accl[2])

        #--------------------------------------------
        if not evntTriggeredXP and not holdclick and gyro[gy1] > threshXP:
            if gy1 == 0: stepX += 1
            if gy1 == 1: stepX -= 1
            vibrar(1,stepX)
            evntTriggeredXP = True
            wait2Zero = False
            cycle = 0

        elif evntTriggeredXP and gyro[gy1] <= threshXP:
            evntTriggeredXP = False
            wait2Zero = True


        if not evntTriggeredXN and not holdclick and gyro[gy1] < threshXN:
            if gy1 == 0: stepX -= 1
            if gy1 == 1: stepX += 1
            vibrar(1,stepX)
            evntTriggeredXN = True
            wait2Zero = False
            cycle = 0

        elif evntTriggeredXN and gyro[gy1] >= threshXN:
            evntTriggeredXN = False
            wait2Zero = True

        if evntTriggeredXP: stepWaitXP += 1
        else: stepWaitXP = 0
        if stepWaitXP >= 5:
            if gy1 == 0: stepX += 1
            if gy1 == 1: stepX -= 1
            stepWaitXP = 0
            vibrar(1,stepX)

        if evntTriggeredXN: stepWaitXN += 1
        else: stepWaitXN = 0
        if stepWaitXN >= 5:
            if gy1 == 0: stepX -= 1
            if gy1 == 1: stepX += 1
            stepWaitXN = 0
            vibrar(1,stepX)
        #--------------------------------------------



        #--------------------------------------------
        if not evntTriggeredYP and not holdclick and gyro[gy2] > threshP:
            if gy2 == 0: stepY += 1
            if gy2 == 1: stepY -= 1
            vibrar(1,stepY)
            evntTriggeredYP = True
            wait2Zero = False
            cycle = 0

        elif evntTriggeredYP and gyro[gy2] <= threshP:
            evntTriggeredYP = False
            wait2Zero = True

        if not evntTriggeredYN and not holdclick and gyro[gy2] < threshN:
            if gy2 == 0: stepY -= 1
            if gy2 == 1: stepY += 1
            vibrar(1,stepY)
            evntTriggeredYN = True
            wait2Zero = False
            cycle = 0

        elif evntTriggeredYN and gyro[gy2] >= threshN:
            evntTriggeredYN = False
            wait2Zero = True
        #--------------------------------------------
        if evntTriggeredYP: stepWaitYP += 1
        else: stepWaitYP = 0
        if stepWaitYP >= 5:
            if gy1 == 0: stepY -= 1
            if gy1 == 1: stepY += 1
            stepWaitYP = 0
            vibrar(1,stepY)

        if evntTriggeredYN: stepWaitYN += 1
        else: stepWaitYN = 0
        if stepWaitYN >= 5:
            if gy1 == 0: stepY += 1
            if gy1 == 1: stepY -= 1
            stepWaitYN = 0
            vibrar(1,stepY)
        #--------------------------------------------

        #print(stepY,stepX,stepWaitXP,stepWaitXN)


        #--------------------------------------------
        #maxCalibratePots
        pval = [pot.read() for pot in [pot1, pot2, pot3, pot4, pot5]]
        #print(pval[0],pval[1],pval[2],pval[3],pval[4])

        for i in range(len(pval)):
            pval[i] = pval[i]-maxCalibratePots[i]

        #print(pval[0],pval[1],pval[2],pval[3],pval[4])
        #pval = [pot.read() for pot in [pot1]]
        #print (pval[0])

        '''
        if num == 0: startlim(limpot, [pval[0],pval[1],pval[2],pval[3]])
        calclim(limpot[0],pval[0])
        calclim(limpot[1],pval[1])
        calclim(limpot[2],pval[2])
        calclim(limpot[3],pval[3])
        print(limpot[0][0],limpot[1][0],limpot[2][0],limpot[3][0])
        '''

        #if num == 0: startlimpot(limpot, [4050, 2800, 2800])

        if stepY == 2 and stepX == -1: abclevel = abcR[0][0]
        elif stepY == 1 and stepX == -1: abclevel = abcR[0][1]
        elif stepY == 0 and stepX == -1: abclevel = abcR[0][2]
        elif stepY == -1 and stepX == -1: abclevel = abcR[0][3]
        elif stepY == -2 and stepX == -1: abclevel = abcR[0][4]

        elif stepY == 2 and stepX == 0: abclevel = abcR[1][0]
        elif stepY == 1 and stepX == 0: abclevel = abcR[1][1]
        elif stepY == 0 and stepX == 0: abclevel = abcR[1][2]
        elif stepY == -1 and stepX == 0: abclevel = abcR[1][3]
        elif stepY == -2 and stepX == 0: abclevel = abcR[1][4]

        elif stepY == 2 and stepX == 1: abclevel = abcR[2][0]
        elif stepY == 1 and stepX == 1: abclevel = abcR[2][1]
        elif stepY == 0 and stepX == 1: abclevel = abcR[2][2]
        elif stepY == -1 and stepX == 1: abclevel = abcR[2][3]
        elif stepY == -2 and stepX == 1: abclevel = abcR[2][4]


        for i in range(5):
            if not triggerPot[i] and pval[i] < threshPot[i]:

                # >>> evento
                #print(i)
                print(stepY,stepX,'\t',abclevel[i],cycle)
                #print(stepY,stepX,'\t',abclevel[i],threshPot[i],pval[i],cycle)

                send_charPs(abclevel[i])
                triggerPot[i] = True
                holdclick = True
                wait2Zero = False
                cycle = 0

            elif triggerPot[i] and pval[i] >= threshPot[i]:
                triggerPot[i] = False
                holdclick = False
                wait2Zero = True

            #if triggerPot[i]:
            #   print(triggerPot[i])
        
        #--------------------------------------------

        if wait2Zero: cycle += 1
        if cycle == 20:
            stepY = 0
            stepX = 0
            vibrar(2)

        if num % tclear == 0: num = 0

        num+=1
        time.sleep_ms(tsleep)


#---------------------------------------------------------------


from hidcodes import hidcodes, abc 

i2c = SoftI2C(scl=Pin(22), sda=Pin(21))
mpuSensor = mpu6050.accel(i2c)

pino_vibracao = Pin(33, Pin.OUT)

vibrar(4)


'''
pot1 = ADC(Pin(34))
pot2 = ADC(Pin(35))
pot3 = ADC(Pin(32))
pot4 = ADC(Pin(33))
#pot5 = ADC(Pin(39))

pot1.atten(ADC.ATTN_11DB)
pot2.atten(ADC.ATTN_11DB)
pot3.atten(ADC.ATTN_11DB)
pot4.atten(ADC.ATTN_11DB)
#pot5.atten(ADC.ATTN_11DB)
'''

pot1 = TouchPad(Pin(13)) #0
pot2 = TouchPad(Pin(12)) #1
pot3 = TouchPad(Pin(14)) #2
pot4 = TouchPad(Pin(27)) #3
pot5 = TouchPad(Pin(4)) #4

#---------------------------------------------------------------
TSLEEP=50
TCLEAR=10000
#TCLEAR=10000
SAMPLES = 5 

run(TSLEEP,TCLEAR,SAMPLES)













=== ARQUIVO: aresp/no_use_r/webrepl_cfg.py ===

PASS = '105474'


=== ARQUIVO: aresp/no_use_r/boot.py ===

import webrepl
'''
import network
import time

print("\nBoot...")
station = network.WLAN(network.STA_IF)

red = [
    ["r2d2rep", "3e4r5t6y7u"],
    ["wff5", "3e4r5t6y7u"],
    ["reno12", "3e4r5t6y7u"],
    ["R2D2", "3e4r5t6y7u"],
    ["wfesp32a", "5t6y7u8i9o"]
]

for i in red:
    station.active(True)
    print(f'Connecting to WiFi {i[0]}...')
    station.connect(i[0], i[1])
    time.sleep_ms(10000)

    if station.isconnected():
        print(f'\nConnected to {i[0]} with success.')
        print(f'Config: {station.ifconfig()}')
        time.sleep_ms(3000)
        break
    else:
        station.active(False)
    
if not station.isconnected():
    print('xxxxxx Error WiFi Connected xxxxxx')
    station.active(False)
'''
print("\n*****************************")
webrepl.start()


=== ARQUIVO: aresp/no_use_r/bkpmain_otimizada.py ===

import time
from machine import Pin, SoftI2C, TouchPad
import mpu6050

# ==== Inicialização de Hardware ====

# Configura o barramento I2C nos pinos do ESP32
i2c = SoftI2C(scl=Pin(22), sda=Pin(21))
# Inicializa o sensor MPU6050
mpuSensor = mpu6050.accel(i2c)
# Pino que controla o motor vibrador
pino_vibracao = Pin(33, Pin.OUT)

# Inicialização dos sensores táteis (TouchPads)
pot1 = TouchPad(Pin(13))
pot2 = TouchPad(Pin(12))
pot3 = TouchPad(Pin(14))
pot4 = TouchPad(Pin(27))
pot5 = TouchPad(Pin(4))
# Lista para fácil iteração
pots = [pot1, pot2, pot3, pot4, pot5]

# ==== Funções auxiliares ====

def vibrar(n_pulsos, step=None):
    """Faz o motor vibrar n_pulsos vezes. Pulso mais longo se step==0."""
    for _ in range(n_pulsos):
        pino_vibracao.on()
        if step == 0:
            time.sleep_ms(200)
        else:
            time.sleep_ms(101)
        pino_vibracao.off()
        time.sleep_ms(70)

def getGyro(buffer):
    """Lê dados crus do MPU6050 e armazena no buffer."""
    mpuData = mpuSensor.get_values()
    buffer[0].append(mpuData['GyX'])
    buffer[1].append(mpuData['GyY'])
    buffer[2].append(mpuData['GyZ'])
    buffer[3].append(mpuData['AcX'])
    buffer[4].append(mpuData['AcY'])
    buffer[5].append(mpuData['AcZ'])
    return buffer

def media(buffer):
    """Calcula a média das leituras no buffer e remove a mais antiga."""
    getGyro(buffer)
    # Médias para giroscópio (primeiros 3) e acelerômetro (últimos 3)
    gyro = [sum(buffer[i]) / len(buffer[i]) for i in range(3)]
    accl = [sum(buffer[i]) / len(buffer[i]) for i in range(3, 6)]
    # Remove a leitura mais antiga
    for i in range(6):
        buffer[i].pop(0)
    return gyro, accl

def calcCalibrate(bufferPot):
    """Calcula o valor máximo registrado para cada touchpad."""
    return [max(potList) for potList in bufferPot]

def getPots(bufferPot, pval):
    """Adiciona leitura atual dos touchpads ao buffer."""
    for i in range(5):
        bufferPot[i].append(pval[i])
    return bufferPot

def check_sensor(value, thresh_pos, thresh_neg,
                 state, holdclick):
    """Verifica se o valor do sensor ultrapassa os limites
       e executa ações associadas."""
    step = state["step"]
    tp = state["trigger_pos"]
    tn = state["trigger_neg"]
    swp = state["stepWait_pos"]
    swn = state["stepWait_neg"]
    wait2Zero = state["wait2Zero"]
    cycle = state["cycle"]

    # Evento: valor acima do limiar positivo
    if not tp and not holdclick and value > thresh_pos:
        step += state["dir_pos"]
        if state["action_pos"]:
            state["action_pos"](step)
        tp = True
        wait2Zero = False
        cycle = 0
    elif tp and value <= thresh_pos:
        tp = False
        wait2Zero = True

    # Evento: valor abaixo do limiar negativo
    if not tn and not holdclick and value < thresh_neg:
        step += state["dir_neg"]
        if state["action_neg"]:
            state["action_neg"](step)
        tn = True
        wait2Zero = False
        cycle = 0
    elif tn and value >= thresh_neg:
        tn = False
        wait2Zero = True

    # Incremento repetitivo enquanto mantido no limiar positivo
    if tp:
        swp += 1
    else:
        swp = 0
    if swp >= 5:
        step += state["dir_pos"]
        swp = 0
        if state["action_pos"]:
            state["action_pos"](step)

    # Incremento repetitivo enquanto mantido no limiar negativo
    if tn:
        swn += 1
    else:
        swn = 0
    if swn >= 5:
        step += state["dir_neg"]
        swn = 0
        if state["action_neg"]:
            state["action_neg"](step)

    # Atualiza o estado do sensor
    state.update(step=step,
                 trigger_pos=tp,
                 trigger_neg=tn,
                 stepWait_pos=swp,
                 stepWait_neg=swn,
                 wait2Zero=wait2Zero,
                 cycle=cycle)
    return state

def start(tsleep, tclear, samples):
    """Função principal que calibra, configura e lê sensores em loop."""
    # Calibração inicial dos touchpads
    bufferPot = [[] for _ in range(5)]
    for _ in range(40):
        pval = [pot.read() for pot in pots]
        getPots(bufferPot, pval)
        time.sleep_ms(70)
    maxCalibratePots = calcCalibrate(bufferPot)

    # Coleta inicial de dados do giroscópio
    buffer = [[] for _ in range(6)]
    for _ in range(samples - 1):
        getGyro(buffer)
        time.sleep_ms(70)

    # Definição de limiares
    poragora = 14000
    thresPercent = 0.1
    threshXP = poragora - (poragora * thresPercent)
    threshXN = -poragora + (poragora * thresPercent)
    threshYP = poragora - (poragora * thresPercent)
    threshYN = -poragora + (poragora * thresPercent)
    threshPot = [-120] * 5

    # Vibra para indicar início
    vibrar(2)

    # Lista de sensores monitorados
    sensors = [
        {   # Giroscópio X
            "name": "gyroX",
            "read": lambda: media(buffer)[0][0],
            "thresh_pos": threshXP,
            "thresh_neg": threshXN,
            "dir_pos": 1, "dir_neg": -1,
            "step": 0,
            "trigger_pos": False, "trigger_neg": False,
            "stepWait_pos": 0, "stepWait_neg": 0,
            "wait2Zero": True, "cycle": 0,
            "action_pos": lambda s: vibrar(1),
            "action_neg": lambda s: vibrar(1)
        },
        {   # Giroscópio Y
            "name": "gyroY",
            "read": lambda: media(buffer)[0][1],
            "thresh_pos": threshYP,
            "thresh_neg": threshYN,
            "dir_pos": 1, "dir_neg": -1,
            "step": 0,
            "trigger_pos": False, "trigger_neg": False,
            "stepWait_pos": 0, "stepWait_neg": 0,
            "wait2Zero": True, "cycle": 0,
            "action_pos": lambda s: vibrar(1),
            "action_neg": lambda s: vibrar(1)
        }
    ]

    # Adiciona os touchpads à lista de sensores
    for i, pot in enumerate(pots):
        sensors.append({
            "name": f"pot{i+1}",
            "read": (lambda p=pot, m=maxCalibratePots[i]: p.read() - m),
            "thresh_pos": threshPot[i],
            "thresh_neg": -9999,
            "dir_pos": 0, "dir_neg": 0,
            "step": 0,
            "trigger_pos": False, "trigger_neg": False,
            "stepWait_pos": 0, "stepWait_neg": 0,
            "wait2Zero": True, "cycle": 0,
            "action_pos": lambda _, lvl=None: send_charPs(lvl) if lvl else None,
            "action_neg": None
        })

    # Loop principal
    while True:
        stepX = sensors[0]["step"]
        stepY = sensors[1]["step"]

        # Determina nível ABC baseado em stepX/Y
        if -1 <= stepX <= 1 and -2 <= stepY <= 2:
            abclevel = [stepX + 1, 2 - stepY]
        else:
            abclevel = None

        # Processa todos os sensores
        for sensor in sensors:
            val = sensor["read"]()
            if "pot" in sensor["name"]:
                sensor.update(check_sensor(
                    val, sensor["thresh_pos"], sensor["thresh_neg"],
                    sensor, holdclick=False
                ))
                # Ajusta action_pos para enviar nível atual
                if sensor["action_pos"]:
                    sensor["action_pos"] = (
                        lambda lvl=abclevel: lambda s: send_charPs(lvl) if lvl else None
                    )()
            else:
                sensor.update(check_sensor(
                    val, sensor["thresh_pos"], sensor["thresh_neg"],
                    sensor, holdclick=False
                ))

        # Reseta contadores se ambos giros voltarem ao zero por tempo suficiente
        if all(s["wait2Zero"] for s in sensors[:2]):
            for s in sensors[:2]:
                s["cycle"] += 1
            if any(s["cycle"] == 20 for s in sensors[:2]):
                sensors[0]["step"] = sensors[1]["step"] = 0
                vibrar(2)

        time.sleep_ms(tsleep)

def send_charPs(abckey):
    """Envia ou imprime comando baseado no valor abckey."""
    print("send_charPs called with:", abckey)

def run():
    """Inicia o sistema com vibração de sinalização."""
    vibrar(4)
    TSLEEP = 50
    TCLEAR = 10000
    SAMPLES = 5
    start(TSLEEP, TCLEAR, SAMPLES)
