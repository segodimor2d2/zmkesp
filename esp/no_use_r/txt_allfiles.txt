=== CONSOLIDAÇÃO DE CÓDIGOS DA PASTA: use ===



=== ARQUIVO: use/hardware.py ===

from machine import Pin, SoftI2C, TouchPad
import mpu6050

def init_hardware():
    i2c = SoftI2C(scl=Pin(22), sda=Pin(21))
    mpuSensor = mpu6050.accel(i2c)

    pino_vibracao = Pin(33, Pin.OUT)

    pots = [
        TouchPad(Pin(13)),
        TouchPad(Pin(12)),
        TouchPad(Pin(14)),
        TouchPad(Pin(27)),
        TouchPad(Pin(4)),
    ]
    return pots, mpuSensor, pino_vibracao


=== ARQUIVO: use/actions.py ===

import time

def vibrar(pino, n_pulsos, step=None):
    if not hasattr(pino, 'on') or not hasattr(pino, 'off'):
        raise TypeError("O parâmetro 'pino' precisa ser um objeto Pin com métodos 'on' e 'off'.")
    for _ in range(n_pulsos):
        pino.on()
        if step == 0:
            time.sleep_ms(200)
        else:
            time.sleep_ms(101)
        pino.off()
        time.sleep_ms(70)

def send_charPs(abckey):
    print(f"TOQUE DETECTADO! Nível: {abckey}")


=== ARQUIVO: use/utils.py ===

import time

def media(valores):
    return sum(valores) / len(valores) if valores else 0

def calibrar_touchpads(pots, amostras=40, delay_ms=70):
    buffers = [[] for _ in pots]
    for _ in range(amostras):
        leituras = [p.read() for p in pots]
        for i, leitura in enumerate(leituras):
            buffers[i].append(leitura)
        time.sleep_ms(delay_ms)

    maximos = [max(b) for b in buffers]
    return maximos


=== ARQUIVO: use/sensors.py ===

import time
from utils import calibrar_touchpads
from actions import vibrar, send_charPs

def check_sensor(value, thresh_pos, state, name):
    if value < thresh_pos and not state["trigger"]:
        state["trigger"] = True
        print(f"[{name}] Toque detectado! Valor: {value}")
        if state["action"]:
            state["action"](state)  # Acho que você quis executar a ação aqui
    elif value >= thresh_pos and state["trigger"]:
        state["trigger"] = False
    return state

def start_sensors(pots, mpuSensor, pino_vibracao, tsleep, tclear, samples):
    import actions
    actions.pino_vibracao = pino_vibracao

    print("Calibrando touchpads...")
    maxCalibratePots = calibrar_touchpads(pots)
    thresholds = [m - 100 for m in maxCalibratePots]

    sensors = []
    for i, pot in enumerate(pots):
        sensors.append({
            "name": f"pot{i+1}",
            "read": lambda p=pot: p.read(),
            "thresh_pos": thresholds[i],
            "trigger": False,
            "action": lambda s, i=i: send_charPs(f"Pot {i+1}")  # Corrigido para captura correta do i
        })

    vibrar(pino_vibracao, 2)  # Passando o pino corretamente
    print("Sistema iniciado. Toque para testar...")

    while True:
        for sensor in sensors:
            val = sensor["read"]()
            sensor.update(check_sensor(val, sensor["thresh_pos"], sensor, sensor["name"]))
        time.sleep_ms(tsleep)


=== ARQUIVO: use/mpu6050.py ===

import machine

class accel():
    def __init__(self, i2c, addr=0x68):
        self.iic = i2c
        self.addr = addr
        self.iic.start()
        self.iic.writeto(self.addr, bytearray([107, 0]))
        self.iic.stop()

    def get_raw_values(self):
        self.iic.start()
        a = self.iic.readfrom_mem(self.addr, 0x3B, 14)
        self.iic.stop()
        return a

    def get_ints(self):
        b = self.get_raw_values()
        c = []
        for i in b:
            c.append(i)
        return c

    def bytes_toint(self, firstbyte, secondbyte):
        if not firstbyte & 0x80:
            return firstbyte << 8 | secondbyte
        return - (((firstbyte ^ 255) << 8) | (secondbyte ^ 255) + 1)

    def get_values(self):
        raw_ints = self.get_raw_values()
        vals = {}
        vals["AcX"] = self.bytes_toint(raw_ints[0], raw_ints[1])
        vals["AcY"] = self.bytes_toint(raw_ints[2], raw_ints[3])
        vals["AcZ"] = self.bytes_toint(raw_ints[4], raw_ints[5])
        vals["Tmp"] = self.bytes_toint(raw_ints[6], raw_ints[7]) / 340.00 + 36.53
        vals["GyX"] = self.bytes_toint(raw_ints[8], raw_ints[9])
        vals["GyY"] = self.bytes_toint(raw_ints[10], raw_ints[11])
        vals["GyZ"] = self.bytes_toint(raw_ints[12], raw_ints[13])
        return vals  # returned in range of Int16
        # -32768 to 32767

    def val_test(self):  # ONLY FOR TESTING! Also, fast reading sometimes crashes IIC
        from time import sleep
        while 1:
            print(self.get_values())
            sleep(0.05)



=== ARQUIVO: use/main.py ===

from hardware import init_hardware
from actions import vibrar
from sensors import start_sensors

def main():
    TSLEEP = 50
    TCLEAR = 10000
    SAMPLES = 5
    
    pots, mpuSensor, pino_vibracao = init_hardware()
    vibrar(pino_vibracao, 4)  # Passa o pino
    start_sensors(pots, mpuSensor, pino_vibracao, TSLEEP, TCLEAR, SAMPLES)
